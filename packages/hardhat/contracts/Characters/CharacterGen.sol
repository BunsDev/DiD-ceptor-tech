// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
// In the game of D&D, creating a new character can be a lot of fun, or take ages and prevent you from playing
// This contract is a simple example of how you can use Chainlink VRF to generate a random character
// A character has 6 ability scores, a class, a name, an alignment, and a background
// Also, there are Traits, Ideals, Bonds, and Flaws, but we'll keep it simple for now
// The character's name, class and background are chosen from on-chain arrays of strings in other contracts
// The ability scores are generated from a single random number using a bitshift and modulo
// Rule Zero in D&D allows the GM to modify rules to enhance gameplay. 
// Gamemasters can change the default amount of rerolls using the more forgiving 4d6 reroll function
import {IVRFCoordinatorV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
import {Names} from "./Names.sol";
import {Backgrounds} from "./Backgrounds.sol";
import {Classes} from "./Classes.sol";
// import {BackstoryGenerator} from "./BackstoryGenerator.sol";
import {BackstoryFunctionClient} from "../BackstoryFunctionClient.sol";

/*
In TTRPGs, Rule Zero grants the Game Master (GM) the authority to modify rules to enhance gameplay and maintain balance, ensuring that all players have an enjoyable experience. This principle can be applied to smart contracts in decentralized gaming, where flexibility is key to adapting to unforeseen scenarios and maintaining fairness. Just as a GM might adjust the difficulty of encounters or allow rerolls to prevent a total party kill, a smart contract can include mechanisms for modifying certain parameters, such as reroll limits, to keep the game balanced and engaging. This flexibility ensures that the gaming experience remains fun and fair, adhering to the spirit of Rule Zero.
*/
contract CharacterGen is VRFConsumerBaseV2Plus {
    IVRFCoordinatorV2Plus COORDINATOR;
    BackstoryFunctionClient public backstoryFunctionClient;
    Names public namesContract;
    Backgrounds public backgroundsContract;
    Classes public classesContract;
    address public gameMaster; // Address of the game master (contract deployer)

    // Modifier to restrict function access to only the game master (aka deployer)
    modifier onlyGameMaster() {
        require(msg.sender == gameMaster, "Only the game master can perform this action");
        _;
    }

    uint256 s_subscriptionId = 21065254117722076320750141452575268873113382931160444158709360180731175497445;
    bytes32 keyHash = 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae;
    uint32 callbackGasLimit = 135000;
    uint16 requestConfirmations = 3;
    uint32 numWords = 2; // Number of random words requested from VRF

    // On deployment, set the reroll limit to 1 by default
    uint8 public rerollLimit = 1;

    // Define the structure for a Character
    struct Character {
        uint256 randomWord;         // Randomness generated by VRF
        uint256 randomWord2;        // Randomness generated by VRF
        uint256[6] abilities;       // Array to hold ability scores
        string class;               // Class of the character
        string playerName;          // Name of the player
        string name;                // Name of the character
        string alignment;           // Alignment of the character
        string background;          // Background story of the character
        uint8 swaps;                // Number of times the player has swapped ability scores
        uint8 rerolls;              // Number of rerolls available for ability scores
        bool isAlive;               // Whether the character is alive or not
    }

    // Mappings to store character and request data
    mapping(uint256 => address) public requestToSender;   // Maps requestId to the sender's address
    mapping(address => Character) public characters;      // Maps player's address to their character

    // Define events to log significant actions
    event CharacterCreated(address indexed owner, uint256 requestId);
    event CharacterUpdated(address indexed owner, string alignment, string background, string _class, string name);
    event ScoresSwapped(address indexed owner);
    event RequestFulfilled(uint256 requestId, uint256[] randomWords);
    event RandomWordsSaved(address indexed owner);
    event infoContractsSet(address namesContract, address backgroundsContract, address classesContract);

    // Constructor to initialize the contract with VRF coordinator address
    constructor() VRFConsumerBaseV2Plus(0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B) {
        COORDINATOR = IVRFCoordinatorV2Plus(0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B);
        gameMaster = msg.sender;
    }

    function setBackstoryFunctionClient(address _backstoryFunctionClient) external onlyOwner() {
        backstoryFunctionClient = BackstoryFunctionClient(_backstoryFunctionClient);
    }
    // Function to set the addresses of the info contracts
    function setRandomContracts(address _namesContract, address _backgroundsContract, address _classesContract) external {
        namesContract = Names(_namesContract);
        backgroundsContract = Backgrounds(_backgroundsContract);
        classesContract = Classes(_classesContract);
        emit infoContractsSet(_namesContract, _backgroundsContract, _classesContract);
    }

    // Function to create a character by requesting random words from the VRF
    function createCharacter(string calldata playerName) external {
        require(characters[msg.sender].randomWord == 0, "Character already created, use finalizeCharacterDetails");
        
        // Request random words from the VRF coordinator
        uint256 requestId = COORDINATOR.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: keyHash,
                subId: s_subscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                extraArgs: VRFV2PlusClient._argsToBytes(
                    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
                )
            })
        );

        // Store the player's name and map the requestId to the sender
        characters[msg.sender].playerName = playerName;
        characters[msg.sender].isAlive = true;
        characters[msg.sender].rerolls = rerollLimit;
        requestToSender[requestId] = msg.sender;

        emit CharacterCreated(msg.sender, requestId);
    }

    // Callback function to handle the VRF response and save the random words
    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override {
        address owner = requestToSender[requestId];
        require(characters[owner].randomWord == 0, "Random words already fulfilled");

        // Save the random words in the character struct
        characters[owner].randomWord = randomWords[0];
        characters[owner].randomWord2 = randomWords[1];

        emit RequestFulfilled(requestId, randomWords);
        emit RandomWordsSaved(owner);
    }

    // Function to finalize the character details using the saved random words
    function finalizeCharacterDetails(string calldata alignment) external {
        require(characters[msg.sender].randomWord != 0, "Random words not fulfilled");

        uint256 randomWord = characters[msg.sender].randomWord;
        uint256 randomWord2 = characters[msg.sender].randomWord2;

        // Generate ability scores from the random word
        for (uint i = 0; i < 6; ++i) {
            uint256 chunk = (randomWord >> (i * 32)) & 0xFFFFFFFF; // Extract 32-bit chunks
            characters[msg.sender].abilities[i] = (chunk % 16) + 3; // Score range: 3-18
        }
        
        // Use random words to generate character name and background
        
        uint256 randomNumber = randomWord % 20;
        characters[msg.sender].name = namesContract.names(randomNumber);
        characters[msg.sender].alignment = alignment;
        randomNumber = randomWord2 % 15;
        characters[msg.sender].background = getBackground(randomNumber);
        
        randomNumber = (randomWord2 >> 32) % 13;
        characters[msg.sender].class = getClass(randomNumber);
        // fetch with class, race, name, background
        string memory characterClass = characters[msg.sender].class;
        string memory characterName = characters[msg.sender].name;
        string memory characterBackground = characters[msg.sender].background;
        fetchBackstory(characterClass, "Dragonborn", characterName, characterBackground);
        emit CharacterUpdated(msg.sender, alignment, characters[msg.sender].background, characters[msg.sender].class, characters[msg.sender].name);

    }

     // Function to allow the game master to update character details
    function gameMasterUpdateCharacter(address player, string calldata name, string calldata alignment, string calldata background, string calldata _class) external onlyGameMaster {
        require(characters[player].randomWord != 0, "Random words not fulfilled, that player needs to be created first");

        // Update character name, alignment, class, and background if provided
        if (bytes(name).length > 0) {
            characters[player].name = name;
        }
        if (bytes(alignment).length > 0) {
            characters[player].alignment = alignment;
        }
        if (bytes(background).length > 0) {
            characters[player].background = background;
        }
        if (bytes(_class).length > 0) {
            characters[player].class = _class;
        }

        emit CharacterUpdated(player, alignment, background, _class, name);
    }


    // Function to allow players to swap ability scores
    function swapScores(uint8 index1, uint8 index2) external {

        require(characters[msg.sender].swaps < 2, "Max swaps reached");
        require(index1 < 6 && index2 < 6, "Invalid index");
        require(index1 != index2, "Cannot swap with the same index");
        require(characters[msg.sender].abilities[index1] != 0 && characters[msg.sender].abilities[index2] != 0, "invalid character, try creating one");
        // Swap the ability scores at the specified indices
        (characters[msg.sender].abilities[index1], characters[msg.sender].abilities[index2]) = 
        (characters[msg.sender].abilities[index2], characters[msg.sender].abilities[index1]);

        characters[msg.sender].swaps++;
        emit ScoresSwapped(msg.sender);
    }

    // Function to get the class of the character based on a random number
    function getClass(uint256 randomNumber) private view returns (string memory) {
    return classesContract.classes(randomNumber % classesContract.classesLength());

    }

    function getBackground(uint256 randomNumber) private view returns (string memory) {
        return backgroundsContract.backgrounds(randomNumber % backgroundsContract.backgroundsLength());
    }

    function getName(uint256 randomNumber) private view returns (string memory) {
        return namesContract.names(randomNumber % namesContract.namesLength());
    }

    function setRerollLimit(uint8 limit) external onlyGameMaster {
        rerollLimit = limit;
    }

    // Function to simulate rolling 4d6 and dropping the lowest die, using Chainlink VRF for randomness
function roll4d6(uint256 randomValue) internal pure returns (uint256) {
    uint256[] memory rolls = new uint256[](4);
    for (uint256 i = 0; i < 4; i++) {
        // Each d6 roll
        rolls[i] = (randomValue % 6) + 1;
        randomValue >>= 3; // Shift right to get new bits for next roll
    }
    // Sort the rolls to find the smallest
    for (uint256 i = 1; i < 4; i++) {
        for (uint256 j = 0; j < i; j++) {
            if (rolls[i] < rolls[j]) {
                (rolls[i], rolls[j]) = (rolls[j], rolls[i]);
            }
        }
    }
    // Sum the highest three rolls
    return rolls[1] + rolls[2] + rolls[3];
}

        function fetchBackstory(string memory characterClass, string memory characterRace, string memory characterName, string memory background) internal {
        backstoryFunctionClient.request(characterClass, characterRace, characterName, background);
    }
    // Function to retrieve the ability scores of a character
    function getCharacterAbilities(address owner) external view returns (uint256[6] memory) {
        return characters[owner].abilities;
    }
}