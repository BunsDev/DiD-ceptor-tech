{
  "31337": {
    "00_backstory_gpt.ts": {
      "name": "00_backstory_gpt.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/00_backstory_gpt.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a D&D 5e backstory for ${CHARACTER_NAME}, a Level 1 ${CHARACTER_CLASS} who is a ${CHARACTER_RACE}. The backstory should be extremely short, dense, powerful, engaging, coherent, and suitable for a fantasy RPG setting. Just reply with the one paragraph backstory and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating a character backstory. Make sure to only use 256 characters or less.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n\n// finds: the response and returns the result (as a string).\nconst backstory = openAIRequest.data.choices[0].message.content;\n\nconsole.log(backstory);\n\nreturn Functions.encodeString(backstory || \"Failed\");\n",
      "checksum": "daa413cb3e545a8f059f666cf22569ea69470f47f8f8826390d16067496cf5e4",
      "subscriptionId": 1,
      "secret": {
        "reference": "0x6c6f63616c3a3100000000000000000000000000000000000000000000000000",
        "validUntil": 1717456833117
      },
      "consumerAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    },
    "01_onboarding_notification.ts": {
      "name": "01_onboarding_notification.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/01_onboarding_notification.ts",
      "source": "async function main(batch, url, auth) {\n  const msgs = await receive(batch, url, auth);\n  for (const i in msgs) {\n    const msg = JSON.parse(msgs[i].payload);\n    const url = msg.url;\n    const apiKey = msg.apiKey;\n    const from = msg.from;\n    const to = msg.to;\n    const username = msg.username;\n    console.log(`url ${url} apiKey ${apiKey}`);\n    await notify(url, apiKey, from, to, username);\n  }\n}\n\nasync function receive(batch, url, auth) {\n  const data = {\n    count: batch,\n    ackmode: \"ack_requeue_false\",\n    encoding: \"auto\",\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Basic ${auth}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: data,\n    timeout: 10_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error) {\n    console.error(`receive msg error: ${response.code} ${response.message}`);\n    throw Error(\"Request failed\");\n  }\n\n  return response.data;\n}\n\nasync function notify(url, apiKey, from, to, username) {\n  const content = `\n    Hi, ${username}:\n  \n    Welcome to join the Ceptor Club,\n  \n    We are a worldwide party of role-players who came together to make an app that would make the process of playing a fantasy RPG together easier and more visually engaging.\n    Learn more: https://ceptor.club/.\n  \n    Please join our discord https://discord.gg/EYZwc7De.\n    `.trim();\n  const msg = {\n    personalizations: [\n      {\n        to: [{ email: to }],\n      },\n    ],\n    from: { email: from },\n    subject: \"Ceptor Club onboarding\",\n    content: [\n      {\n        type: \"text/plain\",\n        value: content,\n      },\n    ],\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: msg,\n    timeout: 20_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error && response.message !== \"SyntaxError: Unexpected end of JSON input\") {\n    console.error(`notify error: ${response.message}`);\n    throw Error(\"Request failed\");\n  } else {\n    console.log(`notify: ${response.statusText} ${response.data}`);\n  }\n}\n\nconst batch = args[0];\nif (!batch) {\n  throw Error(\"batch is missing.\");\n}\n\nconst url = args[1];\nif (!url) {\n  throw Error(\"url is missing.\");\n}\n\nconst auth = secrets.auth;\nif (!auth) {\n  throw Error(\"auth is missing.\");\n}\n\nawait main(parseInt(batch), url, auth);\n\nreturn Functions.encodeString(\"Succeed\");\n",
      "checksum": "07b93b15c2c448f2b19c0f71a3abad10f1c1549771ff9fe0ac99b1199445178b",
      "subscriptionId": 2,
      "secret": {
        "reference": "0x6c6f63616c3a3200000000000000000000000000000000000000000000000000",
        "validUntil": 1717456833117
      },
      "consumerAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    },
    "02_alt_text_for_art_gen.ts": {
      "name": "02_alt_text_for_art_gen.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/02_alt_text_for_art_gen.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\n// gets: character alignment for the backstory.\nconst CHARACTER_ALIGNMENT = args[3]; // --------------> |   Lawful Good\n\n// gets: character background for the backstory.\nconst CHARACTER_BACKGROUND = args[4]; // --------------> |   Noble\n\n// gets: character traits for the backstory.\nconst CHARACTER_TRAITS = args[5]; // --------------> |   Brave and kind-hearted\n\n// gets: character ideals for the backstory.\nconst CHARACTER_IDEALS = args[6]; // --------------> |   Protect the weak\n\n// gets: character bonds for the backstory.\nconst CHARACTER_BONDS = args[7]; // --------------> |   Family\n\n// gets: character flaws for the backstory.\nconst CHARACTER_FLAWS = args[8]; // --------------> |   Trusts too easily\n\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a descriptive alt text for AI art generation based on the following D&D character details:\n- Name: ${CHARACTER_NAME}\n- Class: ${CHARACTER_CLASS}\n- Race: ${CHARACTER_RACE}\n- Alignment: ${CHARACTER_ALIGNMENT}\n- Background: ${CHARACTER_BACKGROUND}\n- Traits: ${CHARACTER_TRAITS}\n- Ideals: ${CHARACTER_IDEALS}\n- Bonds: ${CHARACTER_BONDS}\n- Flaws: ${CHARACTER_FLAWS}\n\nThe alt text should be detailed, engaging, and suitable for generating AI art. Just reply with the alt text and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating alt text for AI art based on character details.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n// finds: the response and returns the result (as a string).\nconst altText = openAIRequest.data?.choices[0].message.content;\n\nconsole.log(`Generated alt text: %s`, altText);\n\nreturn Functions.encodeString(altText || \"Failed\");\n",
      "checksum": "ad0f2748ba4c0b2a05b4d040bcffcca6cf0cff399362ed26e37c34140770cc0f",
      "subscriptionId": 3,
      "secret": {
        "reference": "0x6c6f63616c3a3300000000000000000000000000000000000000000000000000",
        "validUntil": 1717456833117
      },
      "consumerAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  },
  "80002": {
    "00_backstory_gpt.ts": {
      "name": "00_backstory_gpt.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/00_backstory_gpt.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\nconst CHARACTER_BACKGROUND = args[3]; // --------------> |   Trained in the arcane arts from a young age.\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a D&D 5e backstory for ${CHARACTER_NAME}, a Level 1 ${CHARACTER_CLASS} who is a ${CHARACTER_RACE} and has this background ${CHARACTER_BACKGROUND}. The backstory should be extremely short, dense, powerful, engaging, coherent, and suitable for a fantasy RPG setting. Just reply with the one paragraph backstory and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating a character backstory. Make sure to only use 256 characters or less.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n\n// finds: the response and returns the result (as a string).\nconst backstory = openAIRequest.data.choices[0].message.content;\n\nconsole.log(backstory);\n\nreturn Functions.encodeString(backstory || \"Failed\");\n",
      "checksum": "ea5144eb1083e31202aee280629274edff2bf5ca525f9f2a0f712f89106ea0ae",
      "subscriptionId": 238,
      "consumerAddress": "0x26f0EB234DE737fE9dEf0fF1F3206848e55799D8",
      "secret": {
        "reference": "0xa266736c6f744964016776657273696f6e1a665e1ea5",
        "validUntil": 1717530659239
      }
    },
    "01_onboarding_notification.ts": {
      "name": "01_onboarding_notification.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/01_onboarding_notification.ts",
      "source": "async function main(batch, url, auth) {\n  const msgs = await receive(batch, url, auth);\n  for (const i in msgs) {\n    const msg = JSON.parse(msgs[i].payload);\n    const url = msg.url;\n    const apiKey = msg.apiKey;\n    const from = msg.from;\n    const to = msg.to;\n    const username = msg.username;\n    console.log(`url ${url} apiKey ${apiKey}`);\n    await notify(url, apiKey, from, to, username);\n  }\n}\n\nasync function receive(batch, url, auth) {\n  const data = {\n    count: batch,\n    ackmode: \"ack_requeue_false\",\n    encoding: \"auto\",\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Basic ${auth}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: data,\n    timeout: 10_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error) {\n    console.error(`receive msg error: ${response.code} ${response.message}`);\n    throw Error(\"Request failed\");\n  }\n\n  return response.data;\n}\n\nasync function notify(url, apiKey, from, to, username) {\n  const content = `\n    Hi, ${username}:\n  \n    Welcome to join the Ceptor Club,\n  \n    We are a worldwide party of role-players who came together to make an app that would make the process of playing a fantasy RPG together easier and more visually engaging.\n    Learn more: https://ceptor.club/.\n  \n    Please join our discord https://discord.gg/EYZwc7De.\n    `.trim();\n  const msg = {\n    personalizations: [\n      {\n        to: [{ email: to }],\n      },\n    ],\n    from: { email: from },\n    subject: \"Ceptor Club onboarding\",\n    content: [\n      {\n        type: \"text/plain\",\n        value: content,\n      },\n    ],\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: msg,\n    timeout: 20_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error && response.message !== \"SyntaxError: Unexpected end of JSON input\") {\n    console.error(`notify error: ${response.message}`);\n    throw Error(\"Request failed\");\n  } else {\n    console.log(`notify: ${response.statusText} ${response.data}`);\n  }\n}\n\nconst batch = args[0];\nif (!batch) {\n  throw Error(\"batch is missing.\");\n}\n\nconst url = args[1];\nif (!url) {\n  throw Error(\"url is missing.\");\n}\n\nconst auth = secrets.auth;\nif (!auth) {\n  throw Error(\"auth is missing.\");\n}\n\nawait main(parseInt(batch), url, auth);\n\nreturn Functions.encodeString(\"Succeed\");\n",
      "checksum": "07b93b15c2c448f2b19c0f71a3abad10f1c1549771ff9fe0ac99b1199445178b",
      "subscriptionId": 289,
      "consumerAddress": "0x26f0EB234DE737fE9dEf0fF1F3206848e55799D8",
      "secret": {
        "reference": "0xa266736c6f744964026776657273696f6e1a665e1ea6",
        "validUntil": 1717530661907
      }
    },
    "02_alt_text_for_art_gen.ts": {
      "name": "02_alt_text_for_art_gen.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/02_alt_text_for_art_gen.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\n// gets: character alignment for the backstory.\nconst CHARACTER_ALIGNMENT = args[3]; // --------------> |   Lawful Good\n\n// gets: character background for the backstory.\nconst CHARACTER_BACKGROUND = args[4]; // --------------> |   Noble\n\n// gets: character traits for the backstory.\nconst CHARACTER_TRAITS = args[5]; // --------------> |   Brave and kind-hearted\n\n// gets: character ideals for the backstory.\nconst CHARACTER_IDEALS = args[6]; // --------------> |   Protect the weak\n\n// gets: character bonds for the backstory.\nconst CHARACTER_BONDS = args[7]; // --------------> |   Family\n\n// gets: character flaws for the backstory.\nconst CHARACTER_FLAWS = args[8]; // --------------> |   Trusts too easily\n\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a descriptive alt text for AI art generation based on the following D&D character details:\n- Name: ${CHARACTER_NAME}\n- Class: ${CHARACTER_CLASS}\n- Race: ${CHARACTER_RACE}\n- Alignment: ${CHARACTER_ALIGNMENT}\n- Background: ${CHARACTER_BACKGROUND}\n- Traits: ${CHARACTER_TRAITS}\n- Ideals: ${CHARACTER_IDEALS}\n- Bonds: ${CHARACTER_BONDS}\n- Flaws: ${CHARACTER_FLAWS}\n\nThe alt text should be detailed, engaging, and suitable for generating AI art. Just reply with the alt text and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating alt text for AI art based on character details.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n// finds: the response and returns the result (as a string).\nconst altText = openAIRequest.data?.choices[0].message.content;\n\nconsole.log(`Generated alt text: %s`, altText);\n\nreturn Functions.encodeString(altText || \"Failed\");\n",
      "checksum": "ad0f2748ba4c0b2a05b4d040bcffcca6cf0cff399362ed26e37c34140770cc0f",
      "subscriptionId": 297,
      "consumerAddress": "0x26f0EB234DE737fE9dEf0fF1F3206848e55799D8",
      "secret": {
        "reference": "0xa266736c6f744964036776657273696f6e1a665e1ea7",
        "validUntil": 1717530662780
      }
    }
  },
  "84532": {
    "00_backstory_gpt.ts": {
      "name": "00_backstory_gpt.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/00_backstory_gpt.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\nconst CHARACTER_BACKGROUND = args[3]; // --------------> |   Trained in the arcane arts from a young age.\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a D&D 5e backstory for ${CHARACTER_NAME}, a Level 1 ${CHARACTER_CLASS} who is a ${CHARACTER_RACE} and has this background ${CHARACTER_BACKGROUND}. The backstory should be extremely short, dense, powerful, engaging, coherent, and suitable for a fantasy RPG setting. Just reply with the one paragraph backstory and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating a character backstory. Make sure to only use 256 characters or less.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n\n// finds: the response and returns the result (as a string).\nconst backstory = openAIRequest.data.choices[0].message.content;\n\nconsole.log(backstory);\n\nreturn Functions.encodeString(backstory || \"Failed\");\n",
      "checksum": "ea5144eb1083e31202aee280629274edff2bf5ca525f9f2a0f712f89106ea0ae",
      "subscriptionId": 56,
      "consumerAddress": "0x52bfF133bc6A891828baB02fB7338fB943E8D078",
      "secret": {
        "reference": "0xa266736c6f744964016776657273696f6e1a665d1838",
        "validUntil": 1717463478839
      }
    },
    "01_onboarding_notification.ts": {
      "name": "01_onboarding_notification.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/01_onboarding_notification.ts",
      "source": "async function main(batch, url, auth) {\n  const msgs = await receive(batch, url, auth);\n  for (const i in msgs) {\n    const msg = JSON.parse(msgs[i].payload);\n    const url = msg.url;\n    const apiKey = msg.apiKey;\n    const from = msg.from;\n    const to = msg.to;\n    const username = msg.username;\n    console.log(`url ${url} apiKey ${apiKey}`);\n    await notify(url, apiKey, from, to, username);\n  }\n}\n\nasync function receive(batch, url, auth) {\n  const data = {\n    count: batch,\n    ackmode: \"ack_requeue_false\",\n    encoding: \"auto\",\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Basic ${auth}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: data,\n    timeout: 10_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error) {\n    console.error(`receive msg error: ${response.code} ${response.message}`);\n    throw Error(\"Request failed\");\n  }\n\n  return response.data;\n}\n\nasync function notify(url, apiKey, from, to, username) {\n  const content = `\n    Hi, ${username}:\n  \n    Welcome to join the Ceptor Club,\n  \n    We are a worldwide party of role-players who came together to make an app that would make the process of playing a fantasy RPG together easier and more visually engaging.\n    Learn more: https://ceptor.club/.\n  \n    Please join our discord https://discord.gg/EYZwc7De.\n    `.trim();\n  const msg = {\n    personalizations: [\n      {\n        to: [{ email: to }],\n      },\n    ],\n    from: { email: from },\n    subject: \"Ceptor Club onboarding\",\n    content: [\n      {\n        type: \"text/plain\",\n        value: content,\n      },\n    ],\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: msg,\n    timeout: 20_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error && response.message !== \"SyntaxError: Unexpected end of JSON input\") {\n    console.error(`notify error: ${response.message}`);\n    throw Error(\"Request failed\");\n  } else {\n    console.log(`notify: ${response.statusText} ${response.data}`);\n  }\n}\n\nconst batch = args[0];\nif (!batch) {\n  throw Error(\"batch is missing.\");\n}\n\nconst url = args[1];\nif (!url) {\n  throw Error(\"url is missing.\");\n}\n\nconst auth = secrets.auth;\nif (!auth) {\n  throw Error(\"auth is missing.\");\n}\n\nawait main(parseInt(batch), url, auth);\n\nreturn Functions.encodeString(\"Succeed\");\n",
      "checksum": "07b93b15c2c448f2b19c0f71a3abad10f1c1549771ff9fe0ac99b1199445178b",
      "subscriptionId": 59,
      "consumerAddress": "0x52bfF133bc6A891828baB02fB7338fB943E8D078",
      "secret": {
        "reference": "0xa266736c6f744964026776657273696f6e1a665d1839",
        "validUntil": 1717463480951
      }
    },
    "02_alt_text_for_art_gen.ts": {
      "name": "02_alt_text_for_art_gen.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/02_alt_text_for_art_gen.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\n// gets: character alignment for the backstory.\nconst CHARACTER_ALIGNMENT = args[3]; // --------------> |   Lawful Good\n\n// gets: character background for the backstory.\nconst CHARACTER_BACKGROUND = args[4]; // --------------> |   Noble\n\n// gets: character traits for the backstory.\nconst CHARACTER_TRAITS = args[5]; // --------------> |   Brave and kind-hearted\n\n// gets: character ideals for the backstory.\nconst CHARACTER_IDEALS = args[6]; // --------------> |   Protect the weak\n\n// gets: character bonds for the backstory.\nconst CHARACTER_BONDS = args[7]; // --------------> |   Family\n\n// gets: character flaws for the backstory.\nconst CHARACTER_FLAWS = args[8]; // --------------> |   Trusts too easily\n\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a descriptive alt text for AI art generation based on the following D&D character details:\n- Name: ${CHARACTER_NAME}\n- Class: ${CHARACTER_CLASS}\n- Race: ${CHARACTER_RACE}\n- Alignment: ${CHARACTER_ALIGNMENT}\n- Background: ${CHARACTER_BACKGROUND}\n- Traits: ${CHARACTER_TRAITS}\n- Ideals: ${CHARACTER_IDEALS}\n- Bonds: ${CHARACTER_BONDS}\n- Flaws: ${CHARACTER_FLAWS}\n\nThe alt text should be detailed, engaging, and suitable for generating AI art. Just reply with the alt text and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating alt text for AI art based on character details.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n// finds: the response and returns the result (as a string).\nconst altText = openAIRequest.data?.choices[0].message.content;\n\nconsole.log(`Generated alt text: %s`, altText);\n\nreturn Functions.encodeString(altText || \"Failed\");\n",
      "checksum": "ad0f2748ba4c0b2a05b4d040bcffcca6cf0cff399362ed26e37c34140770cc0f",
      "secret": {
        "reference": "0xa266736c6f744964036776657273696f6e1a665d183a",
        "validUntil": 1717463481708
      },
      "subscriptionId": 63,
      "consumerAddress": "0x52bfF133bc6A891828baB02fB7338fB943E8D078"
    }
  },
  "11155111": {
    "00_backstory_gpt.ts": {
      "name": "00_backstory_gpt.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/00_backstory_gpt.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\nconst CHARACTER_BACKGROUND = args[3]; // --------------> |   Trained in the arcane arts from a young age.\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a D&D 5e backstory for ${CHARACTER_NAME}, a Level 1 ${CHARACTER_CLASS} who is a ${CHARACTER_RACE} and has this background ${CHARACTER_BACKGROUND}. The backstory should be extremely short, dense, powerful, engaging, coherent, and suitable for a fantasy RPG setting. Just reply with the one paragraph backstory and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating a character backstory. Make sure to only use 256 characters or less.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n\n// finds: the response and returns the result (as a string).\nconst backstory = openAIRequest.data.choices[0].message.content;\n\nconsole.log(backstory);\n\nreturn Functions.encodeString(backstory || \"Failed\");\n",
      "checksum": "ea5144eb1083e31202aee280629274edff2bf5ca525f9f2a0f712f89106ea0ae",
      "consumerAddress": "0xe1fA8f43D89afE8fcBA4FABbd3e6e6a4C3360409",
      "secret": {
        "reference": "0xa266736c6f744964016776657273696f6e1a665e1ed9",
        "validUntil": 1717530712322
      },
      "subscriptionId": 3022
    },
    "01_onboarding_notification.ts": {
      "name": "01_onboarding_notification.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/01_onboarding_notification.ts",
      "source": "async function main(batch, url, auth) {\n  const msgs = await receive(batch, url, auth);\n  for (const i in msgs) {\n    const msg = JSON.parse(msgs[i].payload);\n    const url = msg.url;\n    const apiKey = msg.apiKey;\n    const from = msg.from;\n    const to = msg.to;\n    const username = msg.username;\n    console.log(`url ${url} apiKey ${apiKey}`);\n    await notify(url, apiKey, from, to, username);\n  }\n}\n\nasync function receive(batch, url, auth) {\n  const data = {\n    count: batch,\n    ackmode: \"ack_requeue_false\",\n    encoding: \"auto\",\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Basic ${auth}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: data,\n    timeout: 10_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error) {\n    console.error(`receive msg error: ${response.code} ${response.message}`);\n    throw Error(\"Request failed\");\n  }\n\n  return response.data;\n}\n\nasync function notify(url, apiKey, from, to, username) {\n  const content = `\n    Hi, ${username}:\n  \n    Welcome to join the Ceptor Club,\n  \n    We are a worldwide party of role-players who came together to make an app that would make the process of playing a fantasy RPG together easier and more visually engaging.\n    Learn more: https://ceptor.club/.\n  \n    Please join our discord https://discord.gg/EYZwc7De.\n    `.trim();\n  const msg = {\n    personalizations: [\n      {\n        to: [{ email: to }],\n      },\n    ],\n    from: { email: from },\n    subject: \"Ceptor Club onboarding\",\n    content: [\n      {\n        type: \"text/plain\",\n        value: content,\n      },\n    ],\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: msg,\n    timeout: 20_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error && response.message !== \"SyntaxError: Unexpected end of JSON input\") {\n    console.error(`notify error: ${response.message}`);\n    throw Error(\"Request failed\");\n  } else {\n    console.log(`notify: ${response.statusText} ${response.data}`);\n  }\n}\n\nconst batch = args[0];\nif (!batch) {\n  throw Error(\"batch is missing.\");\n}\n\nconst url = args[1];\nif (!url) {\n  throw Error(\"url is missing.\");\n}\n\nconst auth = secrets.auth;\nif (!auth) {\n  throw Error(\"auth is missing.\");\n}\n\nawait main(parseInt(batch), url, auth);\n\nreturn Functions.encodeString(\"Succeed\");\n",
      "checksum": "07b93b15c2c448f2b19c0f71a3abad10f1c1549771ff9fe0ac99b1199445178b",
      "subscriptionId": 3023,
      "consumerAddress": "0xe1fA8f43D89afE8fcBA4FABbd3e6e6a4C3360409",
      "secret": {
        "reference": "0xa266736c6f744964026776657273696f6e1a665e1eda",
        "validUntil": 1717530714351
      }
    },
    "02_alt_text_for_art_gen.ts": {
      "name": "02_alt_text_for_art_gen.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/02_alt_text_for_art_gen.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\n// gets: character alignment for the backstory.\nconst CHARACTER_ALIGNMENT = args[3]; // --------------> |   Lawful Good\n\n// gets: character background for the backstory.\nconst CHARACTER_BACKGROUND = args[4]; // --------------> |   Noble\n\n// gets: character traits for the backstory.\nconst CHARACTER_TRAITS = args[5]; // --------------> |   Brave and kind-hearted\n\n// gets: character ideals for the backstory.\nconst CHARACTER_IDEALS = args[6]; // --------------> |   Protect the weak\n\n// gets: character bonds for the backstory.\nconst CHARACTER_BONDS = args[7]; // --------------> |   Family\n\n// gets: character flaws for the backstory.\nconst CHARACTER_FLAWS = args[8]; // --------------> |   Trusts too easily\n\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a descriptive alt text for AI art generation based on the following D&D character details:\n- Name: ${CHARACTER_NAME}\n- Class: ${CHARACTER_CLASS}\n- Race: ${CHARACTER_RACE}\n- Alignment: ${CHARACTER_ALIGNMENT}\n- Background: ${CHARACTER_BACKGROUND}\n- Traits: ${CHARACTER_TRAITS}\n- Ideals: ${CHARACTER_IDEALS}\n- Bonds: ${CHARACTER_BONDS}\n- Flaws: ${CHARACTER_FLAWS}\n\nThe alt text should be detailed, engaging, and suitable for generating AI art. Just reply with the alt text and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating alt text for AI art based on character details.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n// finds: the response and returns the result (as a string).\nconst altText = openAIRequest.data?.choices[0].message.content;\n\nconsole.log(`Generated alt text: %s`, altText);\n\nreturn Functions.encodeString(altText || \"Failed\");\n",
      "checksum": "ad0f2748ba4c0b2a05b4d040bcffcca6cf0cff399362ed26e37c34140770cc0f",
      "subscriptionId": 3024,
      "consumerAddress": "0xe1fA8f43D89afE8fcBA4FABbd3e6e6a4C3360409",
      "secret": {
        "reference": "0xa266736c6f744964036776657273696f6e1a665e1edc",
        "validUntil": 1717530715550
      }
    }
  },
  "11155420": {
    "00_backstory_gpt.ts": {
      "name": "00_backstory_gpt.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/00_backstory_gpt.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a D&D 5e backstory for ${CHARACTER_NAME}, a Level 1 ${CHARACTER_CLASS} who is a ${CHARACTER_RACE}. The backstory should be extremely short, dense, powerful, engaging, coherent, and suitable for a fantasy RPG setting. Just reply with the one paragraph backstory and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating a character backstory. Make sure to only use 256 characters or less.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n\n// finds: the response and returns the result (as a string).\nconst backstory = openAIRequest.data.choices[0].message.content;\n\nconsole.log(backstory);\n\nreturn Functions.encodeString(backstory || \"Failed\");\n",
      "checksum": "daa413cb3e545a8f059f666cf22569ea69470f47f8f8826390d16067496cf5e4",
      "subscriptionId": 190,
      "consumerAddress": "0x0910A0FE7881D332230Ce1FB7f2BaA1Ebe527473",
      "secret": {
        "reference": "0xa266736c6f744964016776657273696f6e1a665d0e1f",
        "validUntil": 1717460894692
      }
    },
    "01_onboarding_notification.ts": {
      "name": "01_onboarding_notification.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/01_onboarding_notification.ts",
      "source": "async function main(batch, url, auth) {\n  const msgs = await receive(batch, url, auth);\n  for (const i in msgs) {\n    const msg = JSON.parse(msgs[i].payload);\n    const url = msg.url;\n    const apiKey = msg.apiKey;\n    const from = msg.from;\n    const to = msg.to;\n    const username = msg.username;\n    console.log(`url ${url} apiKey ${apiKey}`);\n    await notify(url, apiKey, from, to, username);\n  }\n}\n\nasync function receive(batch, url, auth) {\n  const data = {\n    count: batch,\n    ackmode: \"ack_requeue_false\",\n    encoding: \"auto\",\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Basic ${auth}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: data,\n    timeout: 10_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error) {\n    console.error(`receive msg error: ${response.code} ${response.message}`);\n    throw Error(\"Request failed\");\n  }\n\n  return response.data;\n}\n\nasync function notify(url, apiKey, from, to, username) {\n  const content = `\n    Hi, ${username}:\n  \n    Welcome to join the Ceptor Club,\n  \n    We are a worldwide party of role-players who came together to make an app that would make the process of playing a fantasy RPG together easier and more visually engaging.\n    Learn more: https://ceptor.club/.\n  \n    Please join our discord https://discord.gg/EYZwc7De.\n    `.trim();\n  const msg = {\n    personalizations: [\n      {\n        to: [{ email: to }],\n      },\n    ],\n    from: { email: from },\n    subject: \"Ceptor Club onboarding\",\n    content: [\n      {\n        type: \"text/plain\",\n        value: content,\n      },\n    ],\n  };\n\n  const request = Functions.makeHttpRequest({\n    url: url,\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n    data: msg,\n    timeout: 20_000,\n    responseType: \"json\",\n  });\n\n  const response = await request;\n  if (response.error && response.message !== \"SyntaxError: Unexpected end of JSON input\") {\n    console.error(`notify error: ${response.message}`);\n    throw Error(\"Request failed\");\n  } else {\n    console.log(`notify: ${response.statusText} ${response.data}`);\n  }\n}\n\nconst batch = args[0];\nif (!batch) {\n  throw Error(\"batch is missing.\");\n}\n\nconst url = args[1];\nif (!url) {\n  throw Error(\"url is missing.\");\n}\n\nconst auth = secrets.auth;\nif (!auth) {\n  throw Error(\"auth is missing.\");\n}\n\nawait main(parseInt(batch), url, auth);\n\nreturn Functions.encodeString(\"Succeed\");\n",
      "checksum": "07b93b15c2c448f2b19c0f71a3abad10f1c1549771ff9fe0ac99b1199445178b",
      "subscriptionId": 195,
      "consumerAddress": "0x0910A0FE7881D332230Ce1FB7f2BaA1Ebe527473",
      "secret": {
        "reference": "0xa266736c6f744964026776657273696f6e1a665d0e21",
        "validUntil": 1717460896796
      }
    },
    "02_alt_text_for_art_gen.ts": {
      "name": "02_alt_text_for_art_gen.ts",
      "path": "/Users/uklok/Software Development/learning/BlockMagic Hackathon/Ceptor-scaffold-OP/packages/hardhat/functions/02_alt_text_for_art_gen.ts",
      "source": "// [1] ARGUMENT DECLARATION //\n\n// gets: character class for the backstory.\nconst CHARACTER_CLASS = args[0]; // --------------> |   Wizard\n\n// gets: character race for the backstory.\nconst CHARACTER_RACE = args[1]; // --------------> |   Elf\n\nconst CHARACTER_NAME = args[2]; // --------------> |   Eldon\n\n// gets: character alignment for the backstory.\nconst CHARACTER_ALIGNMENT = args[3]; // --------------> |   Lawful Good\n\n// gets: character background for the backstory.\nconst CHARACTER_BACKGROUND = args[4]; // --------------> |   Noble\n\n// gets: character traits for the backstory.\nconst CHARACTER_TRAITS = args[5]; // --------------> |   Brave and kind-hearted\n\n// gets: character ideals for the backstory.\nconst CHARACTER_IDEALS = args[6]; // --------------> |   Protect the weak\n\n// gets: character bonds for the backstory.\nconst CHARACTER_BONDS = args[7]; // --------------> |   Family\n\n// gets: character flaws for the backstory.\nconst CHARACTER_FLAWS = args[8]; // --------------> |   Trusts too easily\n\n// [2] PROMPT ENGINEERING //\n\nconst prompt = `Generate a descriptive alt text for AI art generation based on the following D&D character details:\n- Name: ${CHARACTER_NAME}\n- Class: ${CHARACTER_CLASS}\n- Race: ${CHARACTER_RACE}\n- Alignment: ${CHARACTER_ALIGNMENT}\n- Background: ${CHARACTER_BACKGROUND}\n- Traits: ${CHARACTER_TRAITS}\n- Ideals: ${CHARACTER_IDEALS}\n- Bonds: ${CHARACTER_BONDS}\n- Flaws: ${CHARACTER_FLAWS}\n\nThe alt text should be detailed, engaging, and suitable for generating AI art. Just reply with the alt text and nothing else.`;\n\n// [3] AI DATA REQUEST //\n\n// requests: OpenAI API using Functions\nconst openAIRequest = await Functions.makeHttpRequest({\n  url: `https://api.openai.com/v1/chat/completions`,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${secrets.apiKey}`,\n  },\n  data: {\n    model: \"gpt-3.5-turbo\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are generating alt text for AI art based on character details.\",\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    max_tokens: 50,\n  },\n  timeout: 10_000,\n  responseType: \"json\",\n});\n\nif (openAIRequest.error) throw new Error(\"OpenAI API request failed.\");\n// finds: the response and returns the result (as a string).\nconst altText = openAIRequest.data?.choices[0].message.content;\n\nconsole.log(`Generated alt text: %s`, altText);\n\nreturn Functions.encodeString(altText || \"Failed\");\n",
      "checksum": "ad0f2748ba4c0b2a05b4d040bcffcca6cf0cff399362ed26e37c34140770cc0f",
      "subscriptionId": 196,
      "consumerAddress": "0x0910A0FE7881D332230Ce1FB7f2BaA1Ebe527473",
      "secret": {
        "reference": "0xa266736c6f744964036776657273696f6e1a665d0e22",
        "validUntil": 1717460897563
      }
    }
  }
}