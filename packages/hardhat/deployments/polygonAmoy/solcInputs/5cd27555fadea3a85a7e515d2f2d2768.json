{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_router;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_router = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_router.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_router)) {\n      revert OnlyRouterCanFulfill();\n    }\n    fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n  }\n\n  enum CodeLanguage {\n    JavaScript\n    // In future version we may add other languages\n  }\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_3_0/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"../v1_0_0/interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"../v1_0_0/interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"../v1_0_0/libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_functionsRouter;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_functionsRouter = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_functionsRouter.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function _fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_functionsRouter)) {\n      revert OnlyRouterCanFulfill();\n    }\n    _fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {VRFV2PlusClient} from \"../libraries/VRFV2PlusClient.sol\";\nimport {IVRFSubscriptionV2Plus} from \"./IVRFSubscriptionV2Plus.sol\";\n\n// Interface that enables consumers of VRFCoordinatorV2Plus to be future-proof for upgrades\n// This interface is supported by subsequent versions of VRFCoordinatorV2Plus\ninterface IVRFCoordinatorV2Plus is IVRFSubscriptionV2Plus {\n  /**\n   * @notice Request a set of random words.\n   * @param req - a struct containing following fields for randomness request:\n   * keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * requestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * extraArgs - abi-encoded extra args\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(VRFV2PlusClient.RandomWordsRequest calldata req) external returns (uint256 requestId);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFMigratableConsumerV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The IVRFMigratableConsumerV2Plus interface defines the\n/// @notice method required to be implemented by all V2Plus consumers.\n/// @dev This interface is designed to be used in VRFConsumerBaseV2Plus.\ninterface IVRFMigratableConsumerV2Plus {\n  event CoordinatorSet(address vrfCoordinator);\n\n  /// @notice Sets the VRF Coordinator address\n  /// @notice This method should only be callable by the coordinator or contract owner\n  function setCoordinator(address vrfCoordinator) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFSubscriptionV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The IVRFSubscriptionV2Plus interface defines the subscription\n/// @notice related methods implemented by the V2Plus coordinator.\ninterface IVRFSubscriptionV2Plus {\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint256 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint256 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint256 subId, address to) external;\n\n  /**\n   * @notice Accept subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint256 subId) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint256 subId, address newOwner) external;\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription with LINK, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   * @dev Note to fund the subscription with Native, use fundSubscriptionWithNative. Be sure\n   * @dev  to send Native with the call, for example:\n   * @dev COORDINATOR.fundSubscriptionWithNative{value: amount}(subId);\n   */\n  function createSubscription() external returns (uint256 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return nativeBalance - native balance of the subscription in wei.\n   * @return reqCount - Requests count of subscription.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(\n    uint256 subId\n  )\n    external\n    view\n    returns (uint96 balance, uint96 nativeBalance, uint64 reqCount, address owner, address[] memory consumers);\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint256 subId) external view returns (bool);\n\n  /**\n   * @notice Paginate through all active VRF subscriptions.\n   * @param startIndex index of the subscription to start from\n   * @param maxCount maximum number of subscriptions to return, 0 to return all\n   * @dev the order of IDs in the list is **not guaranteed**, therefore, if making successive calls, one\n   * @dev should consider keeping the blockheight constant to ensure a holistic picture of the contract state\n   */\n  function getActiveSubscriptionIds(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\n\n  /**\n   * @notice Fund a subscription with native.\n   * @param subId - ID of the subscription\n   * @notice This method expects msg.value to be greater than or equal to 0.\n   */\n  function fundSubscriptionWithNative(uint256 subId) external payable;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// End consumer library.\nlibrary VRFV2PlusClient {\n  // extraArgs will evolve to support new features\n  bytes4 public constant EXTRA_ARGS_V1_TAG = bytes4(keccak256(\"VRF ExtraArgsV1\"));\n  struct ExtraArgsV1 {\n    bool nativePayment;\n  }\n\n  struct RandomWordsRequest {\n    bytes32 keyHash;\n    uint256 subId;\n    uint16 requestConfirmations;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    bytes extraArgs;\n  }\n\n  function _argsToBytes(ExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IVRFCoordinatorV2Plus} from \"./interfaces/IVRFCoordinatorV2Plus.sol\";\nimport {IVRFMigratableConsumerV2Plus} from \"./interfaces/IVRFMigratableConsumerV2Plus.sol\";\nimport {ConfirmedOwner} from \"../../shared/access/ConfirmedOwner.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinatorV2Plus.\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBaseV2Plus, and can\n * @dev initialize VRFConsumerBaseV2Plus's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumerV2Plus is VRFConsumerBaseV2Plus {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _subOwner)\n * @dev       VRFConsumerBaseV2Plus(_vrfCoordinator, _subOwner) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create a subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords, extraArgs),\n * @dev see (IVRFCoordinatorV2Plus for a description of the arguments).\n *\n * @dev Once the VRFCoordinatorV2Plus has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBaseV2Plus.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2Plus is IVRFMigratableConsumerV2Plus, ConfirmedOwner {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  error OnlyOwnerOrCoordinator(address have, address owner, address coordinator);\n  error ZeroAddress();\n\n  // s_vrfCoordinator should be used by consumers to make requests to vrfCoordinator\n  // so that coordinator reference is updated after migration\n  IVRFCoordinatorV2Plus public s_vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) ConfirmedOwner(msg.sender) {\n    if (_vrfCoordinator == address(0)) {\n      revert ZeroAddress();\n    }\n    s_vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2Plus expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) external {\n    if (msg.sender != address(s_vrfCoordinator)) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, address(s_vrfCoordinator));\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n\n  /**\n   * @inheritdoc IVRFMigratableConsumerV2Plus\n   */\n  function setCoordinator(address _vrfCoordinator) external override onlyOwnerOrCoordinator {\n    if (_vrfCoordinator == address(0)) {\n      revert ZeroAddress();\n    }\n    s_vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);\n\n    emit CoordinatorSet(_vrfCoordinator);\n  }\n\n  modifier onlyOwnerOrCoordinator() {\n    if (msg.sender != owner() && msg.sender != address(s_vrfCoordinator)) {\n      revert OnlyOwnerOrCoordinator(msg.sender, owner(), address(s_vrfCoordinator));\n    }\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/BuyMeACeptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./GamesToken.sol\";\n\n\n/**\n * @title World\n * @dev World struct\n */\nstruct World {\n    string vibe;\n    string gameMasterName;\n    string gameMasterTwitterHandle;\n    string description;\n    uint256 time;\n    address gameMasterAddress;\n}\n\n/**\n * @title BuyMeACeptorWorld\n * @dev BuyMeACeptorWorld contract to accept donations and for our users to create a world for us\n */\ncontract BuyMeACeptor{\n        address payable public owner;\n    uint256 public price;\n    World[] public worlds;\n\n    GamesToken public gamesToken;\n\n    error InsufficientFunds();\n    error InvalidArguments(string message);\n    error OnlyOwner();\n\n    event BuyMeACeptorWorldEvent(address indexed buyer, uint256 price);\n    event NewWorld(address indexed gameMasterAddress, uint256 time, string vibe, string gameMasterName, string gameMasterTwitterHandle, string description);\n\n    constructor(address _gamesToken) {\n        owner = payable(msg.sender);\n        price = 10 * 10**18; // 10 gamesTokens\n        gamesToken = GamesToken(_gamesToken);\n    }\n\n    /**\n     * WRITE FUNCTIONS *************\n     */\n\n    /**\n     * @dev Function to buy a world\n     * @param  gameMasterName The name of the game master\n     * @param  gameMasterTwitterHandle The Twitter handle of the game master\n     * @param  description The description of the world\n     * (Note: Using calldata for gas efficiency)\n     */\n    function buyWorld(string calldata vibe, string calldata gameMasterName, string calldata gameMasterTwitterHandle, string calldata description) public payable {\n        if (msg.value < price) {\n            revert InsufficientFunds();\n        }\n\n        emit BuyMeACeptorWorldEvent(msg.sender, msg.value);\n\n        if (bytes(gameMasterName).length == 0 && bytes(description).length == 0) {\n            revert InvalidArguments(\"Invalid gameMasterName or description\");\n        }\n\n        worlds.push(World(vibe, gameMasterName, gameMasterTwitterHandle, description, block.timestamp, msg.sender));\n\n        emit NewWorld(msg.sender, block.timestamp, vibe, gameMasterName, gameMasterTwitterHandle, description);\n    }\n\n    /**\n     * @dev Function to remove a world\n     * @param  index The index of the world\n     */\n    function removeWorld(uint256 index) public {\n        if (index >= worlds.length) {\n            revert InvalidArguments(\"Invalid index\");\n        }\n\n        World memory world = worlds[index];\n\n        // if operation isnt sent from the same game master or the owner, then not allowed\n        if (world.gameMasterAddress != msg.sender && msg.sender != owner) {\n            revert InvalidArguments(\"Operation not allowed\");\n        }\n\n        World memory indexWorld = worlds[index];\n        worlds[index] = worlds[worlds.length - 1];\n        worlds[worlds.length - 1] = indexWorld;\n        worlds.pop();\n    }\n\n    /**\n     * @dev Function to modify a world description\n     * @param  index The index of the world\n     * @param  description The description of the world\n     */\n    function modifyWorldDescription(uint256 index, string memory description) public {\n        if (index >= worlds.length) {\n            revert InvalidArguments(\"Invalid index\");\n        }\n\n        World memory world = worlds[index];\n\n        if (world.gameMasterAddress != msg.sender || msg.sender != owner) {\n            revert InvalidArguments(\"Operation not allowed\");\n        }\n\n        worlds[index].description = description;\n    }\n\n    /**\n     * @dev Function to withdraw the balance\n     */\n    function withdrawTips() public {\n        if (msg.sender != owner) {\n            revert OnlyOwner();\n        }\n\n        if (address(this).balance == 0) {\n            revert InsufficientFunds();\n        }\n\n        (bool sent,) = owner.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n     * READ FUNCTIONS *************\n     */\n\n    /**\n     * @dev Function to get the worlds\n     */\n    function getWorlds() public view returns (World[] memory) {\n        return worlds;\n    }\n\n    /**\n     * @dev Recieve function to accept ether\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/CCGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './interfaces/ICCGateway.sol';\nimport {ICCGatewayClient} from './interfaces/ICCGatewayClient.sol';\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\";\n\ncontract CCGateway is ICCGateway, FunctionsClient, AccessControl {\n    using FunctionsRequest for FunctionsRequest.Request;\n\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    bytes32 public constant CLIENT_ROLE = keccak256(\"CLIENT_ROLE\");\n    bytes32 private _donId; // DON ID for the Functions DON to which the requests are sent\n\n    mapping(uint64 subscriptionId => CCGRequest) private _requests; // Each subscription can only handle one kind of request\n    mapping(bytes32 requestId => ICCGatewayClient.CCGResponse) private unprocessed_responses; // Responses that have not been processed yet\n\n    // array of registered subscriptions\n    uint64[] public subscriptions;\n\n    constructor(address router, bytes32 initialDonId, address initialOwner) FunctionsClient(router) {\n        _donId = initialDonId;\n\n        address to = address(0) == initialOwner ? _msgSender() : initialOwner;\n        _grantRole(DEFAULT_ADMIN_ROLE, to);\n        _grantRole(MANAGER_ROLE, to);\n    }\n\n    /**\n     * @dev Set the DON ID\n     * @param newDonId New DON ID\n     */\n    function setDonId(bytes32 newDonId) external onlyRole(getRoleAdmin(MANAGER_ROLE)) {\n        _donId = newDonId;\n    }\n\n    /**\n     * @dev Get the DON ID\n     * @return DON ID\n     */\n    function donId() external view returns (bytes32) {\n        return _donId;\n    }\n\n    function registerRequest(\n        uint64 subscriptionId,\n        FunctionsRequest.Location codeLocation,\n        string calldata source,\n        FunctionsRequest.Location secretsLocation,\n        bytes calldata encryptedSecretsReference,\n        uint32 callbackGasLimit,\n        string calldata name\n    ) external onlyManager {\n        if (bytes(name).length == 0) {revert CCGRequestNameEmpty();}\n\n        CCGRequest storage req = _requests[subscriptionId];\n        if(bytes(req.name).length == 0) {subscriptions.push(subscriptionId);}\n\n        req.name = name;\n        req.callbackGasLimit = callbackGasLimit;\n\n        // Only JavaScript is supported for now\n        req.config.language = FunctionsRequest.CodeLanguage.JavaScript;\n        req.config.codeLocation = codeLocation;\n        req.config.source = source;\n        req.config.secretsLocation = secretsLocation;\n        req.config.encryptedSecretsReference = encryptedSecretsReference;\n    }\n\n    function removeRequest(uint64 subscriptionId) external onlyManager {\n        if (bytes(_requests[subscriptionId].name).length == 0) {revert CCGRequestNotRegistered(subscriptionId);}\n        delete _requests[subscriptionId];\n\n        // Find the index of the subscriptionId in the subscriptions array\n        uint256 index = subscriptions.length;\n        for (uint256 i = 0; i < subscriptions.length; i++) {\n            if (index == subscriptions.length && subscriptions[i] == subscriptionId) index = i;\n            if (index != subscriptions.length && i + 1 < subscriptions.length) subscriptions[i] = subscriptions[i + 1];\n        }\n\n        subscriptions.pop();\n    }\n\n    function getRequest(uint64 subscriptionId) external view returns (CCGRequest memory) {\n        if (bytes(_requests[subscriptionId].name).length == 0) {revert CCGRequestNotRegistered(subscriptionId);}\n        return _requests[subscriptionId];\n    }\n// ---------------------------------------------------------------------------------------------------------------------\n    modifier onlySource(bytes32 requestId) {\n        if (unprocessed_responses[requestId].source != _msgSender()) {revert CCGOnlySameSourceAllowed(requestId);}\n        _;\n    }\n\n    modifier onlyManager() {\n        if (!hasRole(MANAGER_ROLE, tx.origin)) {revert CCGOnlyManagerAllowed();}\n        _;\n    }\n// ---------------------------------------------------------------------------------------------------------------------\n    /**\n     * @notice Triggers an on-demand Functions request using remote encrypted secrets\n     * @param subscriptionId Subscription ID used to pay for request (FunctionsConsumer contract address must first be added to the subscription)\n     * @param args String arguments passed into the source code and accessible via the global variable `args`\n     * @param bytesArgs Bytes arguments passed into the source code and accessible via the global variable `bytesArgs` as hex strings\n     * @param encryptedSecretsReference Reference pointing to encrypted secrets\n     */\n    function sendRequest(\n        uint64 subscriptionId,\n        string[] calldata args,\n        bytes[] calldata bytesArgs,\n        bytes calldata encryptedSecretsReference\n    ) external onlyRole(CLIENT_ROLE) returns (bytes32 requestId) {\n        CCGRequest storage request = _requests[subscriptionId];\n        if (bytes(request.name).length == 0) {revert CCGRequestNotRegistered(subscriptionId);}\n\n        FunctionsRequest.Request memory req = request.config;\n        req.initializeRequest(req.codeLocation, FunctionsRequest.CodeLanguage.JavaScript, req.source);\n        if (encryptedSecretsReference.length > 0) {req.encryptedSecretsReference = encryptedSecretsReference;}\n\n        if (args.length > 0) {\n            req.setArgs(args);\n        }\n        if (bytesArgs.length > 0) {\n            req.setBytesArgs(bytesArgs);\n        }\n\n        requestId = _sendRequest(req.encodeCBOR(), subscriptionId, request.callbackGasLimit, _donId);\n        unprocessed_responses[requestId].state = ICCGatewayClient.CCGResponseState.Sent;\n        unprocessed_responses[requestId].source = _msgSender();\n    }\n\n    /**\n     * @notice Store latest result/error\n     * @param requestId The request ID, returned by sendRequest()\n     * @param response Aggregated response from the user code\n     * @param err Aggregated error from the user code or from the execution pipeline\n     * Either response or error parameter will be set, but never both\n     */\n    function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\n        ICCGatewayClient.CCGResponse storage resp = unprocessed_responses[requestId];\n        if (resp.state != ICCGatewayClient.CCGResponseState.Sent) {revert CCGRequestAlreadyFulfilled(requestId);}\n\n        unprocessed_responses[requestId].state = err.length > 0 ? ICCGatewayClient.CCGResponseState.Error : ICCGatewayClient.CCGResponseState.Success;\n        unprocessed_responses[requestId].data = response;\n        unprocessed_responses[requestId].error = err;\n\n        ICCGatewayClient(resp.source).callback(requestId);\n    }\n\n    /**\n     * @dev Get the response data\n     * @param requestId The request ID, returned by sendRequest()\n     * @return response CCGResponse\n     */\n    function getResponse(bytes32 requestId, bool remove) external onlySource(requestId) returns (ICCGatewayClient.CCGResponse memory response) {\n        response = unprocessed_responses[requestId];\n        if (remove) {delete unprocessed_responses[requestId];}\n    }\n}"
    },
    "contracts/Characters/Backgrounds.sol": {
      "content": "/* experimental smart contract by Tippi Fifestarr for Ceptor Games\n/  simply provide an on-chain querable array of public domain random backstory\n/  other smart contracts can import this or an interface of it to get a backstory\n/  if that contract has a source verifiable of randomness, thats very cool\n/  Ideally, this can be upgraded to request a functions call from the Gateway\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Backgrounds {\n    mapping(address => string) public backstory;\n\n    // note: backstory are as random as you make them\n    // the alphabetical list of d&d 5e srd backgrounds\n    string[15] public backgrounds = [\n    \"Acolyte\",\n    \"Ceptor\",\n    \"Charlatan\",\n    \"Criminal\",\n    \"Entertainer\",\n    \"Folk Hero\",\n    \"Guild Artisan\",\n    \"Hermit\",\n    \"Noble\",\n    \"Outlander\",\n    \"Sage\",\n    \"Sailor\",\n    \"Soldier\",\n    \"Urchin\",\n    \"Vampire\"\n    ];\n    \n    function backgroundsLength() public view returns (uint256) {\n        return backgrounds.length;\n    }\n\n    function setBackstory(string memory _backstory) public {\n        backstory[msg.sender] = _backstory;\n    }\n\n}\n"
    },
    "contracts/Characters/CharacterGen.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n// In the game of D&D, creating a new character can be a lot of fun, or take ages and prevent you from playing\n// This contract is a simple example of how you can use Chainlink VRF to generate a random character\n// A character has 6 ability scores, a class, a name, an alignment, and a background\n// Also, there are Traits, Ideals, Bonds, and Flaws, but we'll keep it simple for now\n// The character's name, class and background are chosen from on-chain arrays of strings in other contracts\n// The ability scores are generated from a single random number using a bitshift and modulo\n// Rule Zero in D&D allows the GM to modify rules to enhance gameplay. \n// Gamemasters can change the default amount of rerolls using the more forgiving 4d6 reroll function\nimport {IVRFCoordinatorV2Plus} from \"@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol\";\nimport {VRFConsumerBaseV2Plus} from \"@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol\";\nimport {VRFV2PlusClient} from \"@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol\";\nimport {Names} from \"./Names.sol\";\nimport {Backgrounds} from \"./Backgrounds.sol\";\nimport {Classes} from \"./Classes.sol\";\n// import {BackstoryGenerator} from \"./BackstoryGenerator.sol\";\nimport {BackstoryFunctionClient} from \"../Clients/BackstoryFunctionClient.sol\";\n\n/*\nIn TTRPGs, Rule Zero grants the Game Master (GM) the authority to modify rules to enhance gameplay and maintain balance, ensuring that all players have an enjoyable experience. This principle can be applied to smart contracts in decentralized gaming, where flexibility is key to adapting to unforeseen scenarios and maintaining fairness. Just as a GM might adjust the difficulty of encounters or allow rerolls to prevent a total party kill, a smart contract can include mechanisms for modifying certain parameters, such as reroll limits, to keep the game balanced and engaging. This flexibility ensures that the gaming experience remains fun and fair, adhering to the spirit of Rule Zero.\n*/\ncontract CharacterGen is VRFConsumerBaseV2Plus {\n    IVRFCoordinatorV2Plus COORDINATOR;\n    BackstoryFunctionClient public backstoryFunctionClient;\n    Names public namesContract;\n    Backgrounds public backgroundsContract;\n    Classes public classesContract;\n    address public gameMaster; // Address of the game master (contract deployer)\n\n    // Modifier to restrict function access to only the game master (aka deployer)\n    modifier onlyGameMaster() {\n        require(msg.sender == gameMaster, \"Only the game master can perform this action\");\n        _;\n    }\n\n    uint256 s_subscriptionId = 21065254117722076320750141452575268873113382931160444158709360180731175497445;\n    bytes32 keyHash = 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae;\n    uint32 callbackGasLimit = 135000;\n    uint16 requestConfirmations = 3;\n    uint32 numWords = 2; // Number of random words requested from VRF\n\n    // On deployment, set the reroll limit to 1 by default\n    uint8 public rerollLimit = 1;\n\n    // Define the structure for a Character\n    struct Character {\n        uint256 randomWord;         // Randomness generated by VRF\n        uint256 randomWord2;        // Randomness generated by VRF\n        uint256[6] abilities;       // Array to hold ability scores\n        string class;               // Class of the character\n        string playerName;          // Name of the player\n        string name;                // Name of the character\n        string alignment;           // Alignment of the character\n        string background;          // Background story of the character\n        uint8 swaps;                // Number of times the player has swapped ability scores\n        uint8 rerolls;              // Number of rerolls available for ability scores\n        bool isAlive;               // Whether the character is alive or not\n    }\n\n    // Mappings to store character and request data\n    mapping(uint256 => address) public requestToSender;   // Maps requestId to the sender's address\n    mapping(address => Character) public characters;      // Maps player's address to their character\n\n    // Define events to log significant actions\n    event CharacterCreated(address indexed owner, uint256 requestId);\n    event CharacterUpdated(address indexed owner, string alignment, string background, string _class, string name);\n    event ScoresSwapped(address indexed owner);\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords);\n    event RandomWordsSaved(address indexed owner);\n    event infoContractsSet(address namesContract, address backgroundsContract, address classesContract);\n\n    // Constructor to initialize the contract with VRF coordinator address\n    constructor() VRFConsumerBaseV2Plus(0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B) {\n        COORDINATOR = IVRFCoordinatorV2Plus(0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B);\n        gameMaster = msg.sender;\n    }\n\n    function setBackstoryFunctionClient(address _backstoryFunctionClient) external onlyOwner() {\n        backstoryFunctionClient = BackstoryFunctionClient(_backstoryFunctionClient);\n    }\n    // Function to set the addresses of the info contracts\n    function setRandomContracts(address _namesContract, address _backgroundsContract, address _classesContract) external {\n        namesContract = Names(_namesContract);\n        backgroundsContract = Backgrounds(_backgroundsContract);\n        classesContract = Classes(_classesContract);\n        emit infoContractsSet(_namesContract, _backgroundsContract, _classesContract);\n    }\n\n    // Function to create a character by requesting random words from the VRF\n    function createCharacter(string calldata playerName) external {\n        require(characters[msg.sender].randomWord == 0, \"Character already created, use finalizeCharacterDetails\");\n        \n        // Request random words from the VRF coordinator\n        uint256 requestId = COORDINATOR.requestRandomWords(\n            VRFV2PlusClient.RandomWordsRequest({\n                keyHash: keyHash,\n                subId: s_subscriptionId,\n                requestConfirmations: requestConfirmations,\n                callbackGasLimit: callbackGasLimit,\n                numWords: numWords,\n                extraArgs: VRFV2PlusClient._argsToBytes(\n                    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})\n                )\n            })\n        );\n\n        // Store the player's name and map the requestId to the sender\n        characters[msg.sender].playerName = playerName;\n        characters[msg.sender].isAlive = true;\n        characters[msg.sender].rerolls = rerollLimit;\n        requestToSender[requestId] = msg.sender;\n\n        emit CharacterCreated(msg.sender, requestId);\n    }\n\n    // Callback function to handle the VRF response and save the random words\n    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override {\n        address owner = requestToSender[requestId];\n        require(characters[owner].randomWord == 0, \"Random words already fulfilled\");\n\n        // Save the random words in the character struct\n        characters[owner].randomWord = randomWords[0];\n        characters[owner].randomWord2 = randomWords[1];\n\n        emit RequestFulfilled(requestId, randomWords);\n        emit RandomWordsSaved(owner);\n    }\n\n    // Function to finalize the character details using the saved random words\n    function finalizeCharacterDetails(string calldata alignment) external {\n        require(characters[msg.sender].randomWord != 0, \"Random words not fulfilled\");\n\n        uint256 randomWord = characters[msg.sender].randomWord;\n        uint256 randomWord2 = characters[msg.sender].randomWord2;\n\n        // Generate ability scores from the random word\n        for (uint i = 0; i < 6; ++i) {\n            uint256 chunk = (randomWord >> (i * 32)) & 0xFFFFFFFF; // Extract 32-bit chunks\n            characters[msg.sender].abilities[i] = (chunk % 16) + 3; // Score range: 3-18\n        }\n        \n        // Use random words to generate character name and background\n        \n        uint256 randomNumber = randomWord % 20;\n        characters[msg.sender].name = namesContract.names(randomNumber);\n        characters[msg.sender].alignment = alignment;\n        randomNumber = randomWord2 % 15;\n        characters[msg.sender].background = getBackground(randomNumber);\n        \n        randomNumber = (randomWord2 >> 32) % 13;\n        characters[msg.sender].class = getClass(randomNumber);\n        // fetch with class, race, name, background\n        string memory characterClass = characters[msg.sender].class;\n        string memory characterName = characters[msg.sender].name;\n        string memory characterBackground = characters[msg.sender].background;\n        fetchBackstory(characterClass, \"Dragonborn\", characterName, characterBackground);\n        emit CharacterUpdated(msg.sender, alignment, characters[msg.sender].background, characters[msg.sender].class, characters[msg.sender].name);\n\n    }\n\n     // Function to allow the game master to update character details\n    function gameMasterUpdateCharacter(address player, string calldata name, string calldata alignment, string calldata background, string calldata _class) external onlyGameMaster {\n        require(characters[player].randomWord != 0, \"Random words not fulfilled, that player needs to be created first\");\n\n        // Update character name, alignment, class, and background if provided\n        if (bytes(name).length > 0) {\n            characters[player].name = name;\n        }\n        if (bytes(alignment).length > 0) {\n            characters[player].alignment = alignment;\n        }\n        if (bytes(background).length > 0) {\n            characters[player].background = background;\n        }\n        if (bytes(_class).length > 0) {\n            characters[player].class = _class;\n        }\n\n        emit CharacterUpdated(player, alignment, background, _class, name);\n    }\n\n\n    // Function to allow players to swap ability scores\n    function swapScores(uint8 index1, uint8 index2) external {\n\n        require(characters[msg.sender].swaps < 2, \"Max swaps reached\");\n        require(index1 < 6 && index2 < 6, \"Invalid index\");\n        require(index1 != index2, \"Cannot swap with the same index\");\n        require(characters[msg.sender].abilities[index1] != 0 && characters[msg.sender].abilities[index2] != 0, \"invalid character, try creating one\");\n        // Swap the ability scores at the specified indices\n        (characters[msg.sender].abilities[index1], characters[msg.sender].abilities[index2]) = \n        (characters[msg.sender].abilities[index2], characters[msg.sender].abilities[index1]);\n\n        characters[msg.sender].swaps++;\n        emit ScoresSwapped(msg.sender);\n    }\n\n    // Function to get the class of the character based on a random number\n    function getClass(uint256 randomNumber) private view returns (string memory) {\n    return classesContract.classes(randomNumber % classesContract.classesLength());\n\n    }\n\n    function getBackground(uint256 randomNumber) private view returns (string memory) {\n        return backgroundsContract.backgrounds(randomNumber % backgroundsContract.backgroundsLength());\n    }\n\n    function getName(uint256 randomNumber) private view returns (string memory) {\n        return namesContract.names(randomNumber % namesContract.namesLength());\n    }\n\n    function setRerollLimit(uint8 limit) external onlyGameMaster {\n        rerollLimit = limit;\n    }\n\n    // Function to simulate rolling 4d6 and dropping the lowest die, using Chainlink VRF for randomness\nfunction roll4d6(uint256 randomValue) internal pure returns (uint256) {\n    uint256[] memory rolls = new uint256[](4);\n    for (uint256 i = 0; i < 4; i++) {\n        // Each d6 roll\n        rolls[i] = (randomValue % 6) + 1;\n        randomValue >>= 3; // Shift right to get new bits for next roll\n    }\n    // Sort the rolls to find the smallest\n    for (uint256 i = 1; i < 4; i++) {\n        for (uint256 j = 0; j < i; j++) {\n            if (rolls[i] < rolls[j]) {\n                (rolls[i], rolls[j]) = (rolls[j], rolls[i]);\n            }\n        }\n    }\n    // Sum the highest three rolls\n    return rolls[1] + rolls[2] + rolls[3];\n}\n\n        function fetchBackstory(string memory characterClass, string memory characterRace, string memory characterName, string memory background) internal {\n        backstoryFunctionClient.generateBackstory(characterClass, characterRace, characterName, background);\n    }\n    // Function to retrieve the ability scores of a character\n    function getCharacterAbilities(address owner) external view returns (uint256[6] memory) {\n        return characters[owner].abilities;\n    }\n}"
    },
    "contracts/Characters/Classes.sol": {
      "content": "/* Experimental smart contract by Tippi Fifestarr for Ceptor Games\n/  This contract provides an on-chain queryable array of D&D character classes\n/  Other smart contracts can import this or an interface of it to get a class\n/  If that contract has a source verifiable of randomness, that's even better\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Classes {\n\n    // Note: Classes are as random as you make them\n    // The list of D&D 5e SRD classes\n    string[13] public classes = [\n    \"Barbarian\",\n    \"Bard\",\n    \"Cleric\",\n    \"Druid\",\n    \"Fighter\",\n    \"Monk\",\n    \"Paladin\",\n    \"Ranger\",\n    \"Rogue\",\n    \"Sorcerer\",\n    \"Warlock\",\n    \"Wizard\",\n    \"Ceptor\"\n    ];\n\n    function classesLength() public view returns (uint256) {\n        return classes.length;\n    }\n\n}"
    },
    "contracts/Characters/Names.sol": {
      "content": "/* experimental smart contract by Tippi Fifestarr for Ceptor Games\n/  simply provide an on-chain querable array of public domain character names\n/  other smart contracts can import this or an interface of it to get a name\n/  if that contract has a source verifiable of randomness, thats cool\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Names {\n\n    // note: names are as random as you make them\n    // the alphabetical list\n    string[20] public names = [\n    \"Aladdin\",\n    \"Alice\",\n    \"Arthur\",\n    \"Davy\",\n    \"Dracula\",\n    \"Felix\",\n    \"Frankie\",\n    \"Hercules\",\n    \"Jack\",\n    \"James\",\n    \"Kong\",\n    \"Lupin\",\n    \"Merlin\",\n    \"Nyarlathotep\",\n    \"Nemo\",\n    \"Oswald\",\n    \"Red\",\n    \"Sandman\",\n    \"Sherlock\",\n    \"Winnie\"\n    ];\n    \n    function namesLength() public view returns (uint256) {\n        return names.length;\n    }\n}\n"
    },
    "contracts/Clients/BackstoryFunctionClient.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {ICCGatewayClient} from \"../interfaces/ICCGatewayClient.sol\";\nimport {ICCGateway} from \"../interfaces/ICCGateway.sol\";\nimport {Backgrounds} from \"../Characters/Backgrounds.sol\";\n\ncontract BackstoryFunctionClient is ICCGatewayClient {\n    ICCGateway private immutable gateway;\n\n    uint64 public BACKSTORY_ENDPOINT = 0;\n    uint64 public ART_ALT_ENDPOINT = 0;\n    mapping(address => string) public backstory;\n    mapping(address => string) public altArt;\n\n    constructor(address gatewayAddress) {\n        gateway = ICCGateway(gatewayAddress);\n    }\n\n    function setBackstoryEndpoint(uint64 _subscriptionId) external {\n        BACKSTORY_ENDPOINT = _subscriptionId;\n    }\n\n    function setArtAltEndpoint(uint64 _subscriptionId) external {\n        ART_ALT_ENDPOINT = _subscriptionId;\n    }\n\n    // CLASS --------------> |  Wizard\n    // RACE --------------> |   Elf\n    // NAME --------------> |   Eldon\n    function generateBackstory(string calldata characterClass, string calldata characterRace, string calldata characterName, string calldata background) external {\n        require(BACKSTORY_ENDPOINT != 0, \"Backstory Endpoint ID not set\");\n\n        string[] memory args = new string[](4);\n        args[0] = characterClass;\n        args[1] = characterRace;\n        args[2] = characterName;\n        args[3] = background;\n\n        bytes[] memory bytesArgs = new bytes[](0); // No bytes arguments for this function\n\n        gateway.sendRequest(BACKSTORY_ENDPOINT, args, bytesArgs, \"\");\n    }\n\n    function handleBackstoryResponse(ICCGatewayClient.CCGResponse memory response) internal {\n        backstory[msg.sender] = string(response.data);\n    }\n\n    // CLASS[0] --------------> |  Wizard\n    // RACE[1] --------------> |   Elf\n    // NAME[2] --------------> |   Eldon\n    // ALIGNMENT[3] --------------> |  Neutral Good\n    // BACKGROUND[4] --------------> |  Sage\n    // TRAITS[4] --------------> | Brave and kind-hearted\n    // IDEALS[5] --------------> | Protect the weak\n    // BONDS[6] --------------> |  Family\n    // FLAWS[7] --------------> |  Trusts too easily\n    function generateArtAlt(string[] calldata characterDetails) external {\n        require(ART_ALT_ENDPOINT != 0, \"Art Alt Endpoint ID not set\");\n\n        bytes[] memory bytesArgs = new bytes[](0); // No bytes arguments for this function\n\n        gateway.sendRequest(ART_ALT_ENDPOINT, characterDetails, bytesArgs, \"\");\n    }\n\n    function handleArtAltResponse(ICCGatewayClient.CCGResponse memory response) internal {\n        altArt[msg.sender] = string(response.data);\n    }\n\n    function callback(bytes32 requestId) external override {\n        ICCGatewayClient.CCGResponse memory response = gateway.getResponse(requestId, true);\n\n        if (response.state == ICCGatewayClient.CCGResponseState.Success) {\n            if (response.subscriptionId == BACKSTORY_ENDPOINT)\n                return handleBackstoryResponse(response);\n            if (response.subscriptionId == ART_ALT_ENDPOINT)\n                return handleArtAltResponse(response);\n        }\n    }\n}\n"
    },
    "contracts/Clients/CCExampleClient.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {ICCGatewayClient} from \"../interfaces/ICCGatewayClient.sol\";\nimport {ICCGateway} from \"../interfaces/ICCGateway.sol\";\n\ncontract CCExampleClient is ICCGatewayClient {\n    ICCGateway private immutable gateway;\n\n    uint64 public subscriptionId = 0;\n    bytes public encryptedSecretsReference = \"\";\n\n    event ResponseReceived(uint64 subscriptionId, bytes32 requestId, string response);\n    event ErrorReceived(uint64 subscriptionId, bytes32 requestId, string error);\n\n    constructor(address gatewayAddress) {\n        gateway = ICCGateway(gatewayAddress);\n    }\n\n    function updateSubscriptionId(uint64 _subscriptionId) external {\n        subscriptionId = _subscriptionId;\n    }\n\n    function updateEncryptedSecretsReference(bytes calldata _encryptedSecretsReference) external {\n        encryptedSecretsReference = _encryptedSecretsReference;\n    }\n\n    function request(string[] calldata args, bytes[] calldata bytesArgs) external {\n        require(subscriptionId != 0, \"Subscription ID not set\");\n\n        gateway.sendRequest(subscriptionId, args, bytesArgs, encryptedSecretsReference);\n    }\n\n    function callback(bytes32 requestId) external override {\n        ICCGatewayClient.CCGResponse memory response = gateway.getResponse(requestId, true);\n\n        if (response.state == ICCGatewayClient.CCGResponseState.Success) {\n            emit ResponseReceived(response.subscriptionId, requestId, string(response.data));\n        } else {\n            emit ErrorReceived(response.subscriptionId, requestId, string(response.error));\n        }\n    }\n}\n"
    },
    "contracts/Clients/CCNotificationClient.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {CCExampleClient} from \"./CCExampleClient.sol\";\n\ncontract CCNotificationClient is CCExampleClient {\n    constructor(address gatewayAddress) CCExampleClient(gatewayAddress) {}\n}\n"
    },
    "contracts/GamesDAOv3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Games Token deployed on Polygon Amoy\n\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title GamesDAO\n * @dev Manages the minting and pricing of GamesToken based on Chainlink price feeds. \n * Allows for gamemaster proposals on token pricing, updating a catchphrase, decentralized withdrawl, players and gamemasters voting.\n * Chainlink Block Magic Hackathon for Ceptor Games Team by Tippi Fifestarr.\n */\ninterface TokenInterface {\n    function mint(address account, uint256 amount) external;\n}\n\ncontract GamesDAOv3 is AccessControl {\n    AggregatorV3Interface internal priceFeed;\n    TokenInterface public minter;\n    uint256 public gamesTokenPriceInCents = 2; // 1 token = 0.02 USD\n    address public immutable owner;\n    string public greeting = \"Hooty, world!\";\n\n    bytes32 public constant GAMEMASTER_ROLE = keccak256(\"GAMEMASTER_ROLE\");\n    bytes32 public constant PLAYER_ROLE = keccak256(\"PLAYER_ROLE\");\n    uint256 public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** 18;\n    // mapping(address => bool) public allowedPlayers; // using the oz access control roles instead\n\n    enum ProposalType {CHANGE_PRICE, SEND_FUNDS, UPDATE_CATCHPHRASE}\n\nstruct Proposal {\n    ProposalType proposalType;\n    string catchphrase;\n    uint256 newPrice;\n    uint256 amount;\n    address to;\n    uint256 votesFor;\n    uint256 votesAgainst;\n    uint256 deadline;\n    bool executed;\n    mapping(address => bool) voters;\n}\n\n    struct Player {\n        string catchphrase;\n    }\n\n    struct Gamemaster {\n        string catchphrase;\n        string stylePrompt;\n    }\n\n    mapping(address => Player) public players;\n    mapping(address => Gamemaster) public gamemasters;\n    Proposal public proposal;\n\n    event PlayerAllowed(address indexed player);\n    event GamemasterAdded(address indexed gamemaster);\n    event ProposalCreated(uint256 newPrice, uint256 amount, address to, string catchphrase, uint256 deadline, ProposalType proposalType);\n    event Voted(address indexed voter, bool voteFor);\n    event ProposalExecuted(uint256 newPrice, uint256 amount, address to, string catchphrase, ProposalType proposalType);\n    event PlayerCatchphraseUpdated(address indexed player, string catchphrase);\n    event GamemasterCatchphraseUpdated(address indexed gamemaster, string catchphrase);\n    event GamemasterStylePromptUpdated(address indexed gamemaster, string stylePrompt);\n\n    /**\n     * @dev Sets the owner, roles and initializes the MATIC/USD price feed on the Polygon Amoy Testnet.\n     */\n    constructor() {\n        priceFeed = AggregatorV3Interface(0x001382149eBa3441043c1c66972b4772963f5D43);\n        owner = msg.sender;\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n        _grantRole(GAMEMASTER_ROLE, owner);\n        _grantRole(PLAYER_ROLE, owner);\n    }\n\n    /**\n     * @dev Ensures only the owner can call the modified function.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    /**\n     * @dev Ensures only allowed players or gamemasters can call the modified function.\n     */\n    modifier onlyAllowed() {\n    require(\n        hasRole(PLAYER_ROLE, msg.sender) || hasRole(GAMEMASTER_ROLE, msg.sender),\n        \"Not allowed\"\n    );\n    _;\n    }\n\n    /**\n     * @notice Sets the token contract address for minting.\n     * @param tokenAddress The address of the token contract.\n     */\n    function setTokenAddress(address tokenAddress) external onlyOwner {\n        minter = TokenInterface(tokenAddress);\n    }\n\n    /**\n     * @notice Retrieves the latest price of MATIC in USD from the Chainlink data feed.\n     * @return price The latest MATIC price in USD.\n     */\n    function getChainlinkDataFeedLatestAnswer() public view returns (int) {\n        (, int price,,,) = priceFeed.latestRoundData();\n        return price; // example returned amount 69050000 = $0.69 USD for 1 Matic\n    }\n\n     /**\n     * @notice Calculates the amount of MATIC required to buy one GamesToken.\n     * @return gamesTokenPriceInWei The amount of MATIC (18 decimals) needed for one GamesToken.\n     */\n    function getMATICForOneGT() public view returns (uint256) {\n    int price = getChainlinkDataFeedLatestAnswer(); // value of 1 MATIC (1 ) is 0.69 USD (8 decimals) = 69050000\n\n    // Convert the price to uint256\n    uint256 priceInCents = uint256(price) / 10**6; // Convert from 8 decimals to cents (e.g., 69050000 -> 69)\n\n    // Calculate the amount of MATIC needed for one GamesToken in wei\n    uint256 gamesTokenPriceWei = (gamesTokenPriceInCents * 10**18) / priceInCents;\n    \n    return gamesTokenPriceWei;\n}\n\n    /**\n     * @notice Calculates the total MATIC required for a given number of GamesTokens.\n     * @param numberOfGTs The number of GamesTokens to buy.\n     * @return howMuchMatic The total amount of MATIC needed for the specified number of GamesTokens.\n     */\n    function getMATICForGTs(uint256 numberOfGTs) public view returns (uint256) {\n        return getMATICForOneGT() * numberOfGTs;\n    }\n\n    /**\n     * @notice Allows players to buy a specified number of GamesTokens.\n     * @param numberOfGTs The number of GamesTokens to buy.\n     */\n    function buyAmountTokens(uint256 numberOfGTs) public payable onlyAllowed {\n        uint256 requiredMATIC = getMATICForGTs(numberOfGTs);\n        require(msg.value >= requiredMATIC, \"Insufficient MATIC sent\");\n        minter.mint(msg.sender, numberOfGTs * TOKEN_DECIMAL_MULTIPLIER);\n    }\n\n    /**\n     * @notice Allows players to buy GamesTokens based on the amount of MATIC sent.\n     */\n    function buyTokens() public payable onlyAllowed {\n        require(msg.value > 0, \"No MATIC sent\");\n        uint256 numberOfGTs = (msg.value) / getMATICForOneGT();\n        minter.mint(msg.sender, numberOfGTs * TOKEN_DECIMAL_MULTIPLIER);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw the contract balance.\n     */\n    function withdraw() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n   /**\n * @notice Allows the owner to permit a player to participate.\n * @param player The address of the player to be allowed.\n */\nfunction allowPlayer(address player) external onlyOwner {\n    grantRole(PLAYER_ROLE, player);\n    emit PlayerAllowed(player);\n}\n\n    /**\n     * @notice Allows the owner to designate a gamemaster.\n     * @param gamemaster The address of the gamemaster to be added.\n     */\n    function addGamemaster(address gamemaster) external onlyOwner {\n        grantRole(GAMEMASTER_ROLE, gamemaster);\n        emit GamemasterAdded(gamemaster);\n    }\n\n    /**\n * @notice Creates a proposal for various actions like changing token price, updating catchphrase, or sending funds.\n * @param proposalType The type of proposal.\n * @param newPrice The new price for the token in cents (for CHANGE_PRICE).\n * @param amount The amount of funds to send (for SEND_FUNDS).\n * @param catchphrase The new catchphrase (for UPDATE_CATCHPHRASE).\n */\nfunction createProposal(ProposalType proposalType, uint256 newPrice, uint256 amount, address to, string calldata catchphrase) external onlyAllowed {\n    require(proposal.deadline == 0 || block.timestamp > proposal.deadline, \"Previous proposal still active\");\n\n    proposal.proposalType = proposalType;\n    proposal.newPrice = newPrice;\n    proposal.amount = amount;\n    proposal.to = to;\n    proposal.catchphrase = catchphrase;\n    proposal.votesFor = 0;\n    proposal.votesAgainst = 0;\n    proposal.deadline = block.timestamp + 1 hours;\n    proposal.executed = false;\n\n    emit ProposalCreated(newPrice, amount, to, catchphrase, proposal.deadline, proposalType);\n\n}\n\n    /**\n     * @notice Allows allowed users to vote on the active proposal.\n     * @param voteFor True to vote in favor, false to vote against.\n     */\n    function vote(bool voteFor) external onlyAllowed {\n        require(block.timestamp <= proposal.deadline, \"Voting period has ended\");\n        require(!proposal.voters[msg.sender], \"Already voted\");\n        proposal.voters[msg.sender] = true;\n        if (voteFor) {\n            proposal.votesFor += 1;\n        } else {\n            proposal.votesAgainst += 1;\n        }\n        emit Voted(msg.sender, voteFor);\n    }\n\n   /**\n * @notice Executes the proposal if voting is complete and conditions are met.\n */\nfunction executeProposal() external onlyAllowed {\n    require(block.timestamp > proposal.deadline, \"Voting period not ended yet\");\n    require(!proposal.executed, \"Proposal already executed\");\n    require(proposal.votesFor > proposal.votesAgainst, \"Proposal not approved\");\n\n    if (proposal.proposalType == ProposalType.CHANGE_PRICE) {\n        gamesTokenPriceInCents = proposal.newPrice;\n    } else if (proposal.proposalType == ProposalType.SEND_FUNDS) {\n        require(address(this).balance >= proposal.amount, \"Insufficient balance\");\n        payable(proposal.to).transfer(proposal.amount);\n    } else if (proposal.proposalType == ProposalType.UPDATE_CATCHPHRASE) {\n        greeting = proposal.catchphrase;\n    }\n\n    proposal.executed = true;\n    proposal.deadline = 0;\n\n    emit ProposalExecuted(proposal.newPrice, proposal.amount, proposal.to, proposal.catchphrase, proposal.proposalType);\n}\n\n/**\n * @notice Allows a player to update their catchphrase.\n * @param catchphrase The new catchphrase for the player.\n */\n    function updatePlayerCatchphrase(string calldata catchphrase) external onlyRole(PLAYER_ROLE) {\n        players[msg.sender].catchphrase = catchphrase;\n        emit PlayerCatchphraseUpdated(msg.sender, catchphrase);\n    }\n\n/**\n * @notice Allows a gamemaster to update their catchphrase.\n * @param catchphrase The new catchphrase for the gamemaster.\n */\n    function updateGamemasterCatchphrase(string calldata catchphrase) external onlyRole(GAMEMASTER_ROLE) {\n        gamemasters[msg.sender].catchphrase = catchphrase;\n        emit GamemasterCatchphraseUpdated(msg.sender, catchphrase);\n    }\n\n/**\n * @notice Allows a gamemaster to update their style prompt.\n * @param stylePrompt The new style prompt for the gamemaster.\n */\n    function updateGamemasterStylePrompt(string calldata stylePrompt) external onlyRole(GAMEMASTER_ROLE) {\n        gamemasters[msg.sender].stylePrompt = stylePrompt;\n        emit GamemasterStylePromptUpdated(msg.sender, stylePrompt);\n    }\n}"
    },
    "contracts/GamesToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract GamesToken is ERC20, AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor() ERC20(\"GamesToken\", \"GT\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(MINTER_ROLE, msg.sender);\n    }\n\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function addMinter(address minter) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(MINTER_ROLE, minter);\n    }\n\n    function removeMinter(address minter) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _revokeRole(MINTER_ROLE, minter);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}"
    },
    "contracts/interfaces/ICCGateway.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {ICCGatewayClient} from './ICCGatewayClient.sol';\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/v1_3_0/FunctionsClient.sol\";\n\ninterface ICCGateway {\n    struct CCGRequest {\n        string name;\n        uint32 callbackGasLimit;\n        FunctionsRequest.Request config;\n    }\n\n    /**\n     * @dev Can't register a request with an empty name\n     */\n    error CCGRequestNameEmpty();\n\n    /**\n     * @dev Only the same source of the requestId is allowed to call the function\n     */\n    error CCGOnlySameSourceAllowed(bytes32 requestId);\n\n    /**\n     * @dev Only a registered subscriptionId is allowed to call the function\n     */\n    error CCGRequestNotRegistered(uint64 subscriptionId);\n\n    /**\n     * @dev Can't fulfill a request that has already been fulfilled\n     */\n    error CCGRequestAlreadyFulfilled(bytes32 requestId);\n\n    /**\n     * @dev Only A manager can call the function\n     */\n    error CCGOnlyManagerAllowed();\n\n    /**\n     * @dev Send a request to the Functions DON\n     */\n    function sendRequest(\n        uint64 subscriptionId,\n        string[] calldata args,\n        bytes[] calldata bytesArgs,\n        bytes calldata encryptedSecretsReference\n    ) external returns (bytes32 requestId);\n\n    function getResponse(bytes32 requestId, bool remove) external returns (ICCGatewayClient.CCGResponse memory resp);\n}\n"
    },
    "contracts/interfaces/ICCGatewayClient.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface ICCGatewayClient {\n    enum CCGResponseState {Sent, Success, Error}\n\n    struct CCGResponse {\n        uint64 subscriptionId;\n        address source;\n        CCGResponseState state;\n        bytes data;\n        bytes error;\n    }\n\n    function callback(bytes32 requestId) external;\n}\n"
    },
    "contracts/TokenShop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\ninterface TokenInterface {\n    function mint(address account, uint256 amount) external;\n}\n\ncontract TokenShop {\n    // Native Network PAIR\n    AggregatorV3Interface internal priceFeed;\n    // gamesToken is 18 decimal places, and we want to sell 1 token for 0.02 usd\n    TokenInterface public minter;\n    uint256 public gamesTokenPriceInCents = 2; // for testing 1 token = 0.02 usd, in the chainlink 8 decimal place return format\n    address public owner;\n\n    mapping(address => bool) public allowedPlayers;\n    mapping(address => bool) public gamemasters;\n\n    struct Proposal {\n        uint256 newPrice;\n        uint256 votesFor;\n        uint256 votesAgainst;\n        uint256 deadline;\n        bool executed;\n        mapping(address => bool) voters;\n    }\n\n    Proposal public proposal;\n\n    event PlayerAllowed(address indexed player);\n    event GamemasterAdded(address indexed gamemaster);\n    event ProposalCreated(uint256 newPrice, uint256 deadline);\n    event Voted(address indexed voter, bool voteFor);\n    event ProposalExecuted(uint256 newPrice);\n\n    constructor(address aggregator) {\n        priceFeed = AggregatorV3Interface(aggregator);\n        owner = msg.sender;\n        allowedPlayers[owner] = true;\n        gamemasters[owner] = true;\n    }\n\n    /**\n    * Allow the admin to change the token address\n    */\n    function setTokenAddress(address tokenAddress) external onlyOwner {\n        minter = TokenInterface(tokenAddress);\n    }\n\n    /**\n    * Returns the latest answer\n    */\n    function getChainlinkDataFeedLatestAnswer() public view returns (int) {\n        (\n        /*uint80 roundID*/,\n            int price,\n        /*uint startedAt*/,\n        /*uint timeStamp*/,\n        /*uint80 answeredInRound*/\n        ) = priceFeed.latestRoundData();\n        return price;\n    }\n\n    function getMATICForOneGT() public view returns (uint256) {\n        uint256 maticPriceInUSD = uint256(getChainlinkDataFeedLatestAnswer()); // MATIC price in USD with 8 decimal places\n        uint256 maticForOneCent = 10 ** 10 / maticPriceInUSD; // Calculate MATIC amount for one cent\n        uint256 maticForOneGT = maticForOneCent * gamesTokenPriceInCents; // tokenPrice is in cents\n        return maticForOneGT;\n    }\n\n    function getMATICForGTs(uint256 numberOfGTs) public view returns (uint256) {\n        uint256 maticForOneGT = getMATICForOneGT();\n        uint256 totalMATICForGTs = maticForOneGT * numberOfGTs;\n        return totalMATICForGTs;\n    }\n\n    function buyAmountTokens(uint256 numberOfGTs) public payable onlyAllowed {\n        uint256 requiredMATIC = getMATICForGTs(numberOfGTs);\n        require(msg.value >= requiredMATIC, \"Insufficient MATIC sent\");\n\n        minter.mint(msg.sender, numberOfGTs * 10 ** 18); // Minting tokens with proper decimal adjustment\n    }\n\n    // based on the amount sent in, give the number of tokens as long as its over the price of one token\n    function buyTokens() public payable onlyAllowed {\n        require(msg.value >= getMATICForOneGT(), \"Insufficient MATIC sent\");\n        uint256 numberOfGTs = msg.value / getMATICForOneGT();\n        minter.mint(msg.sender, numberOfGTs * 10 ** 18); // Minting tokens with proper decimal adjustment\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function withdraw() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function allowPlayer(address player) external onlyOwner {\n        allowedPlayers[player] = true;\n        emit PlayerAllowed(player);\n    }\n\n    function addGamemaster(address gamemaster) external onlyOwner {\n        gamemasters[gamemaster] = true;\n        emit GamemasterAdded(gamemaster);\n    }\n\n    modifier onlyAllowed() {\n        require(allowedPlayers[msg.sender] || gamemasters[msg.sender], \"Not allowed\");\n        _;\n    }\n\n    function createProposal(uint256 newPrice) external onlyAllowed {\n        require(proposal.deadline == 0 || block.timestamp > proposal.deadline, \"Previous proposal still active\");\n\n        proposal.newPrice = newPrice;\n        proposal.votesFor = 0;\n        proposal.votesAgainst = 0;\n        proposal.deadline = block.timestamp + 1 weeks;\n        proposal.executed = false;\n\n        emit ProposalCreated(newPrice, proposal.deadline);\n    }\n\n    function vote(bool voteFor) external onlyAllowed {\n        require(block.timestamp <= proposal.deadline, \"Voting period has ended\");\n        require(!proposal.voters[msg.sender], \"Already voted\");\n\n        proposal.voters[msg.sender] = true;\n\n        if (voteFor) {\n            proposal.votesFor += 1;\n        } else {\n            proposal.votesAgainst += 1;\n        }\n\n        emit Voted(msg.sender, voteFor);\n    }\n\n    function executeProposal() external onlyAllowed {\n        require(block.timestamp > proposal.deadline, \"Voting period not ended yet\");\n        require(!proposal.executed, \"Proposal already executed\");\n\n        uint256 totalVotes = proposal.votesFor + proposal.votesAgainst;\n        uint256 requiredVotes = totalVotes / 2;\n\n        if (proposal.votesFor >= requiredVotes) {\n            gamesTokenPriceInCents = proposal.newPrice;\n            emit ProposalExecuted(proposal.newPrice);\n        }\n\n        proposal.executed = true;\n    }\n}\n"
    },
    "contracts/World.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ncontract World {\n    struct Game {\n        address gameMaster;\n        uint256 startTime;\n        uint256 endTime;\n        address[] players;\n        mapping(address => bool) isPlayer;\n    }\n\n    string public vibe;\n    string public gameMasterName;\n    string public gameMasterTwitterHandle;\n    string public description;\n    uint256 public creationTime;\n    address public worldCreator;\n    uint256 public treasuryBalance;\n\n    uint256 public gameCount;\n    mapping(uint256 => Game) public games;\n    \n    event WorldUpdated(string vibe, string gameMasterName, string gameMasterTwitterHandle, string description);\n    event GameCreated(uint256 gameId, address gameMaster, uint256 startTime, uint256 endTime);\n    event PlayerJoined(uint256 gameId, address player);\n    event PlayerApproved(uint256 gameId, address player);\n\n    constructor(\n        string memory _vibe,\n        string memory _gameMasterName,\n        string memory _gameMasterTwitterHandle,\n        string memory _description,\n        address _worldCreator\n    ) {\n        vibe = _vibe;\n        gameMasterName = _gameMasterName;\n        gameMasterTwitterHandle = _gameMasterTwitterHandle;\n        description = _description;\n        creationTime = block.timestamp;\n        worldCreator = _worldCreator;\n    }\n\n    modifier onlyGameMaster(uint256 gameId) {\n        require(msg.sender == games[gameId].gameMaster, \"Not the game master\");\n        _;\n    }\n\n    function createGame(uint256 startTime, uint256 endTime) public {\n        games[gameCount].gameMaster = msg.sender;\n        games[gameCount].startTime = startTime;\n        games[gameCount].endTime = endTime;\n        gameCount++;\n\n        emit GameCreated(gameCount - 1, msg.sender, startTime, endTime);\n    }\n\n    function joinGame(uint256 gameId) public payable {\n        require(gameId < gameCount, \"Game does not exist\");\n        require(msg.value >= 1 ether, \"Insufficient stake\");\n\n        games[gameId].players.push(msg.sender);\n        games[gameId].isPlayer[msg.sender] = true;\n        treasuryBalance += msg.value;\n\n        emit PlayerJoined(gameId, msg.sender);\n    }\n\n    function approvePlayer(uint256 gameId, address player) public onlyGameMaster(gameId) {\n        require(games[gameId].isPlayer[player], \"Player not in the game\");\n\n        // Additional logic to approve player if needed\n        emit PlayerApproved(gameId, player);\n    }\n\n    function updateDescription(string memory _description) public {\n        require(msg.sender == worldCreator, \"Operation not allowed\");\n        description = _description;\n        emit WorldUpdated(vibe, gameMasterName, gameMasterTwitterHandle, description);\n    }\n}\n"
    },
    "contracts/WorldFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"./World.sol\";\n\ncontract WorldFactory {\n    address public owner;\n    uint256 public priceToCreate;\n    uint256 public priceToJoinGM;\n    uint256 public priceToJoinPlayer;\n    World[] public worlds;\n\n    error InsufficientFunds();\n    error InvalidArguments(string message);\n    error OnlyOwner();\n\n    event WorldCreated(address indexed worldCreator, address worldContract, uint256 time, string vibe, string gameMasterName, string gameMasterTwitterHandle, string description);\n    event PlayerJoinedWorld(address indexed worldContract, address player);\n    event GameScheduled(address indexed worldContract, uint256 gameId, address gameMaster, uint256 startTime, uint256 endTime);\n    event GameStarted(address indexed worldContract, uint256 gameId);\n    event GameJoined(address indexed worldContract, uint256 gameId, address player);\n    event GameLeft(address indexed worldContract, uint256 gameId, address player);\n    event GameReviewed(address indexed worldContract, uint256 gameId, address reviewer);\n\n    constructor() {\n        owner = msg.sender;\n        priceToCreate = .1 ether;   // Example price to create a world\n        priceToJoinGM = .05 ether;    // Example price for GM to join a world\n        priceToJoinPlayer = .02 ether; // Example price for player to join a world\n    }\n\n    /**\n     * @dev Function to create a world\n     * @param vibe The vibe of the world\n     * @param gameMasterName The name of the game master\n     * @param gameMasterTwitterHandle The Twitter handle of the game master\n     * @param description The description of the world\n     */\n    function createWorld(\n        string calldata vibe,\n        string calldata gameMasterName,\n        string calldata gameMasterTwitterHandle,\n        string calldata description\n    ) public payable {\n        if (msg.value < priceToCreate) {\n            revert InsufficientFunds();\n        }\n\n        World world = new World(vibe, gameMasterName, gameMasterTwitterHandle, description, msg.sender);\n        worlds.push(world);\n\n        emit WorldCreated(msg.sender, address(world), block.timestamp, vibe, gameMasterName, gameMasterTwitterHandle, description);\n    }\n\n    /**\n     * @dev Function for a GM to join a world\n     * @param worldIndex The index of the world to join\n     */\n    function joinWorldAsGM(uint256 worldIndex) public payable {\n        if (worldIndex >= worlds.length) {\n            revert InvalidArguments(\"World does not exist\");\n        }\n        if (msg.value < priceToJoinGM) {\n            revert InsufficientFunds();\n        }\n\n        World world = worlds[worldIndex];\n        payable(world.worldCreator()).transfer(priceToJoinGM / 2);\n        payable(address(world)).transfer(priceToJoinGM / 2);\n\n        emit PlayerJoinedWorld(address(world), msg.sender);\n    }\n\n    /**\n     * @dev Function for a player to join a world\n     * @param worldIndex The index of the world to join\n     */\n    function joinWorldAsPlayer(uint256 worldIndex) public payable {\n        if (worldIndex >= worlds.length) {\n            revert InvalidArguments(\"World does not exist\");\n        }\n        if (msg.value < priceToJoinPlayer) {\n            revert InsufficientFunds();\n        }\n\n        World world = worlds[worldIndex];\n        payable(world.worldCreator()).transfer(priceToJoinPlayer / 2);\n        payable(address(world)).transfer(priceToJoinPlayer / 2);\n\n        emit PlayerJoinedWorld(address(world), msg.sender);\n    }\n\n    /**\n     * @dev Function to withdraw the balance\n     */\n    function withdrawFunds() public {\n        if (msg.sender != owner) {\n            revert OnlyOwner();\n        }\n\n        if (address(this).balance == 0) {\n            revert InsufficientFunds();\n        }\n\n        (bool sent,) = owner.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n     * @dev Function to get the worlds\n     */\n    function getWorlds() public view returns (World[] memory) {\n        return worlds;\n    }\n\n    /**\n     * @dev Receive function to accept ether\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/ZKSecretCharacter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n// Deployed on zkSync Sepolia Testnet: https://sepolia.explorer.zksync.io/address/0xA6bA847c70cB1eea5811f8C79632C09CF0478FCA#contract\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title ZKSecrets\n * @dev This contract allows users to store secrets on-chain. \n * Each user has their own mapping of secrets. \n * The contract uses Chainlink price feeds to check for a payment of 0.1 USD for each secret stored.\n */\ncontract ZKSecrets {\n    AggregatorV3Interface internal dataFeed;\n    mapping(address => bytes32[5]) private secrets;\n\n    /**\n     * @dev Constructor sets the address for the Chainlink price feed.\n     * The address is for the ETH/USD price feed on the zkSync Sepolia Testnet.\n     */\n    constructor() {\n        dataFeed = AggregatorV3Interface(\n            0xfEefF7c3fB57d18C5C6Cdd71e45D2D0b4F9377bF\n        );\n    }\n\n    /**\n     * @dev Stores secrets for the sender. Requires a payment of 0.1 USD.\n     * @param _secrets An array of secrets to be stored.\n     */\n        function storeSecrets(bytes32[5] memory _secrets) public payable {\n        require(msg.value >= (uint(getLatestPrice()) / 10000), \"Payment of 0.3 USD required\");\n        secrets[msg.sender] = _secrets;\n    }\n\n    /**\n     * @dev Returns the latest price from the Chainlink price feed.\n     * @return The latest price.\n     */\n    function getLatestPrice() public view returns (int) {\n        (\n            /* uint80 roundID */,\n            int price,\n            /*uint startedAt*/,\n            /*uint timeStamp*/,\n            /*uint80 answeredInRound*/\n        ) = dataFeed.latestRoundData();\n        return price; // example answer: 377586779077\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}